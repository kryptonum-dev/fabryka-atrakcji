---
import imageToInlineSvg from '@/src/utils/image-to-inline-svg'
import Button, { ButtonDataQuery, type ButtonDataProps } from '../ui/button'
import Image, { ImageDataQuery, type ImageDataProps } from '../ui/image'
import PortableText, { PortableTextQuery, type PortableTextValue } from '../ui/portable-text'

export const StepsList_Query = `
  _type == "StepsList" => {
    imageColumns[]{
      blockObject{
        text,
        "icon": icon.asset->url,
      },
      ${ImageDataQuery('images[]')}
    },
    ${PortableTextQuery('heading')}
    ${PortableTextQuery('paragraph')}
    steps[]{
      ${PortableTextQuery('heading')}
      ${PortableTextQuery('paragraph')}
      blocks[]{
        _type,
        _type == "ctaBlock" => {
          ${ButtonDataQuery('cta')}
          ${PortableTextQuery('text')}
        },
        _type == "imageBlock" => {
          textIconBlock{
            text,
            "icon": icon.asset->url,
          },
          ${PortableTextQuery('text')}
        },
      },
    },
  },
`

type Props = {
  index: number
  sectionId?: string
  imageColumns: {
    blockObject: {
      text: string
      icon: string
    }
    images: ImageDataProps[]
  }[]
  heading: PortableTextValue
  paragraph: PortableTextValue
  steps: {
    heading: PortableTextValue
    paragraph: PortableTextValue
    blocks?: (
      | {
          _type: 'ctaBlock'
          cta: ButtonDataProps
          text: PortableTextValue
        }
      | {
          _type: 'imageBlock'
          textIconBlock: {
            text: string
            icon: string
          }
          text: PortableTextValue
        }
    )[]
  }[]
}

const { index, sectionId, imageColumns, heading, paragraph, steps } = Astro.props

const imageColumnsSvg = await Promise.all(
  imageColumns.map(async (column) => await imageToInlineSvg(column.blockObject.icon))
)

const stepBlockSvg = await Promise.all(
  steps.map(async (step) => {
    if (!step.blocks) return []
    return await Promise.all(
      step.blocks.map(async (block) =>
        block._type === 'imageBlock' ? await imageToInlineSvg(block.textIconBlock.icon) : null
      )
    )
  })
)

console.log(stepBlockSvg)
---

<section class="StepsList" id={sectionId}>
  <div class="columns">
    {
      imageColumns.map((column, columnIndex) => (
        <div class="col">
          <div class="container">
            <div class="box">
              <Fragment set:html={imageColumnsSvg[columnIndex]} />
              <span>{column.blockObject.text}</span>
            </div>{' '}
            <div class="wrapper">
              {[...column.images, ...column.images, ...column.images].map((image, imageIndex) => (
                <div class="img" data-visible={imageIndex === 7 ? 'true' : 'false'}>
                  <Image {...image} sizes="" />
                </div>
              ))}
            </div>
          </div>
        </div>
      ))
    }
  </div>
  <div class="content">
    <header class="header">
      <PortableText value={heading} class="heading" heading={index === 0 ? 'h1' : 'h2'} />
      <PortableText value={paragraph} class="paragraph" />
    </header>
    <ul class="steps">
      {
        steps.map(({ heading, paragraph, blocks }, stepIndex) => (
          <li class="step">
            <PortableText value={heading} class="step-heading" heading={index === 0 ? 'h2' : 'h3'} />
            <PortableText value={paragraph} class="step-paragraph" />
            {blocks && (
              <ul class="blocks">
                {blocks.map((block, blockIndex) => (
                  <li class="block" data-type={block._type}>
                    {block._type === 'ctaBlock' && <Button {...block.cta} />}
                    {block._type === 'imageBlock' && (
                      <div class="image-block">
                        <Fragment set:html={stepBlockSvg[stepIndex][blockIndex]} />
                        <span>{block.textIconBlock.text}</span>
                      </div>
                    )}
                    <PortableText value={block.text} class="text" />
                  </li>
                ))}
              </ul>
            )}
          </li>
        ))
      }
    </ul>
  </div>
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get column wrappers and containers
    const columnWrappers = document.querySelectorAll('.StepsList .col .wrapper')
    const containers = document.querySelectorAll('.StepsList .col .container')
    const imagesWrapper1 = columnWrappers[0].querySelectorAll('.img')
    const imagesWrapper2 = columnWrappers[1].querySelectorAll('.img')
    if (columnWrappers.length !== 2) return

    const INTERVAL_TIME = 2200 //
    const TRANSITION_DURATION = 1300 //
    const RESET_DELAY = TRANSITION_DURATION + 100 // Add a small buffer to ensure animation completes
    const IMAGE_COUNT = 5 // Number of unique images per column

    // Different center positions for each column
    const CENTER_IMAGE_INDICES = [
      0, // First column (moving down) centers on 3rd image (index 2)
      0, // Second column (moving up) centers on 3rd image (index 2)
    ]

    let intervalId: number | null = null // Track the interval ID
    let isAnimating = false // Flag to prevent multiple animations running concurrently
    let currentVisibleImage = [7, 7]

    // Calculate the total height of a single item (image + gap)
    const calculateItemHeight = (): number => {
      const firstImage = columnWrappers[0].querySelector('.img')
      const wrapper = columnWrappers[0] as HTMLElement

      // Get the computed style to extract the gap
      const wrapperStyle = window.getComputedStyle(wrapper)
      const gapValue = wrapperStyle.getPropertyValue('gap') || '0.5rem'

      // Convert gap to pixels (approximate)
      const gapSize = gapValue.includes('rem')
        ? parseFloat(gapValue) * 16 // assuming 1rem = 16px
        : parseFloat(gapValue)

      if (firstImage) {
        const imageHeight = (firstImage as HTMLElement).offsetHeight
        return imageHeight + gapSize
      }

      // Fallback
      return 210 // approx image + small gap
    }

    const updateVisibleImages = (firstIndex: number, secondIndex: number) => {
      imagesWrapper1.forEach((image) => {
        image.setAttribute('data-visible', 'false')
      })

      imagesWrapper1[firstIndex].setAttribute('data-visible', 'true')

      imagesWrapper2.forEach((image) => {
        image.setAttribute('data-visible', 'false')
      })

      imagesWrapper2[secondIndex].setAttribute('data-visible', 'true')

      currentVisibleImage = [firstIndex, secondIndex]
    }

    // Get the height measurement
    const itemHeight = calculateItemHeight()

    // Position containers in the center of columns first
    containers.forEach((container) => {
      const containerElement = container as HTMLElement
      containerElement.style.position = 'absolute'
      containerElement.style.top = '50%'
      containerElement.style.transform = 'translateY(-50%)'
    })

    // Calculate initial position to center the desired image for each column
    const calculateInitialPosition = (columnIndex: number): number => {
      // Calculate center offset based on the appropriate center image for this column
      // Column 0 moves down (negative initial), Column 1 moves up (positive initial)
      return CENTER_IMAGE_INDICES[columnIndex] * itemHeight * (columnIndex === 0 ? -1 : 1)
    }

    // Initialize tracking variables
    const initialPositions = [calculateInitialPosition(0), calculateInitialPosition(1)]
    let currentPositions = [...initialPositions]

    columnWrappers.forEach((wrapper) => {
      ;(wrapper as HTMLElement).style.transition = `transform ${TRANSITION_DURATION}ms cubic-bezier(0.19,1,0.22,1)`
    })

    // Function to reset wrapper position without animation
    const resetWrapper = (index: number): void => {
      const wrapper = columnWrappers[index] as HTMLElement

      // Temporarily remove transition
      wrapper.style.transition = 'none'

      imagesWrapper1.forEach((image) => {
        image.setAttribute('data-transition', 'false')
      })

      imagesWrapper2.forEach((image) => {
        image.setAttribute('data-transition', 'false')
      })

      imagesWrapper1[7].setAttribute('data-visible', 'true')
      imagesWrapper2[7].setAttribute('data-visible', 'true')

      // Reset to initial position
      currentPositions[index] = initialPositions[index]
      wrapper.style.transform = `none`

      // Force reflow to ensure the transition removal takes effect
      wrapper.offsetHeight

      console.log(currentVisibleImage)

      // imagesWrapper1[currentVisibleImage[0]].setAttribute('data-visible', 'false')
      // imagesWrapper2[currentVisibleImage[1]].setAttribute('data-visible', 'false')
      currentVisibleImage = [7, 7]

      imagesWrapper1.forEach((image) => {
        image.setAttribute('data-transition', 'true')
      })

      imagesWrapper2.forEach((image) => {
        image.setAttribute('data-transition', 'true')
      })
      // Restore transition
      wrapper.style.transition = `transform ${TRANSITION_DURATION}ms cubic-bezier(0.19,1,0.22,1)`
    }

    // Handle scrolling animation
    const scrollColumns = (): void => {
      // Prevent multiple animations from running simultaneously
      if (isAnimating) return
      isAnimating = true

      // Calculate movement distance (include gap)
      const moveDistance = itemHeight

      // Column 1 - scroll down (increase Y value)
      currentPositions[0] += moveDistance
      ;(columnWrappers[0] as HTMLElement).style.transform = `translateY(${currentPositions[0]}px)`

      // Column 2 - scroll up (decrease Y value)
      currentPositions[1] -= moveDistance
      ;(columnWrappers[1] as HTMLElement).style.transform = `translateY(${currentPositions[1]}px)`

      updateVisibleImages(currentVisibleImage[0] - 1, currentVisibleImage[1] + 1)

      // Track how many images we've moved
      const movedImages = [
        Math.abs((currentPositions[0] - initialPositions[0]) / itemHeight),
        Math.abs((currentPositions[1] - initialPositions[1]) / itemHeight),
      ]

      // Check position limits for reset
      const needsReset = [
        movedImages[0] >= IMAGE_COUNT, // Reset column 1
        movedImages[1] >= IMAGE_COUNT, // Reset column 2
      ]

      // Allow next animation after current one completes
      setTimeout(() => {
        // Reset wrappers if needed
        if (needsReset[0]) {
          resetWrapper(0)
        }

        if (needsReset[1]) {
          resetWrapper(1)
        }

        // Clear animation flag to allow next animation
        isAnimating = false
      }, RESET_DELAY)
    }

    // Function to start the animation interval
    const startAnimation = (): void => {
      // Clear any existing interval first
      if (intervalId !== null) {
        clearInterval(intervalId)
      }

      // Start new interval and store the ID
      intervalId = setInterval(scrollColumns, INTERVAL_TIME) as unknown as number
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      // Pause animation during resize
      if (intervalId !== null) {
        clearInterval(intervalId)
        intervalId = null
      }

      // Recalculate dimensions
      const newItemHeight = calculateItemHeight()

      // Recalculate initial positions
      initialPositions[0] = CENTER_IMAGE_INDICES[0] * newItemHeight * -1
      initialPositions[1] = CENTER_IMAGE_INDICES[1] * newItemHeight * 1

      // Reset positions without animation
      columnWrappers.forEach((wrapper, i) => {
        const wrapperElement = wrapper as HTMLElement

        // Remove transition
        wrapperElement.style.transition = 'none'

        // Reset position
        currentPositions[i] = initialPositions[i]
        wrapperElement.style.transform = `translateY(${currentPositions[i]}px)`

        // Force reflow
        wrapperElement.offsetHeight
      })

      // Restore transition
      columnWrappers.forEach((wrapper) => {
        ;(wrapper as HTMLElement).style.transition = `transform ${TRANSITION_DURATION}ms cubic-bezier(0.19,1,0.22,1)`
      })

      // Reset animation flag
      isAnimating = false

      // Restart animation after small delay
      setTimeout(() => {
        startAnimation()
      }, 100)
    })

    // Start the animation
    startAnimation()
  })
</script>

<style lang="scss">
  .StepsList {
    display: grid;
    grid-template-columns: 1fr auto;
    max-width: 85.375rem;
    margin: 0 auto;
    .columns {
      padding: 0.675rem;
      background: var(--neutral-200, #f5f1ec);
      border-radius: clamp(16px, calc(32vw / 7.68), 32px);
      max-height: 46.75rem;
      position: sticky;
      top: 1.25rem;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      padding: 0 1rem;
      overflow: hidden;
      gap: clamp(0.25rem, calc(0.5rem / 0.48), 0.75rem);

      .col {
        position: relative;
        display: grid;
        place-items: center;
        overflow: hidden;

        &:nth-of-type(1) {
          margin-bottom: -3.75rem;
        }

        &:nth-of-type(2) {
          margin-top: -3.75rem;
        }

        .container {
          position: relative;
          display: grid;
          gap: clamp(0.25rem, calc(0.5rem / 0.48), 0.5rem);

          .box {
            position: absolute;
            top: 50%;
            left: 50%;
            display: flex;
            align-items: center;
            background: var(--primary-800, #45051c);
            border-radius: 999px;
            color: var(--neutral-400, #ffe4ca);
            gap: 0.375rem;
            font-variant-numeric: lining-nums proportional-nums;
            padding: 0.375rem 0.625rem 0.5rem 0.5rem;
            font-size: var(--typography-body-xl, 1.125rem);
            line-height: 1.5;
            z-index: 2;

            :global(svg) {
              padding-top: 2px;
            }
          }
          .wrapper {
            display: grid;
            gap: clamp(0.25rem, calc(0.5rem / 0.48), 0.5rem);
            .img {
              border-radius: 4px;
              overflow: hidden;
              position: relative;
              height: 195px;

              &::before {
                content: '';
                position: absolute;
                inset: 0;
                background: rgba(245, 241, 236, 0.6);
                transition: opacity 800ms;
              }
              &[data-visible='true'] {
                &::before {
                  opacity: 0;
                }
              }

              &[data-transition='false'] {
                &::before {
                  transition: none !important;
                }
              }
              img {
              }
            }
          }
        }

        &:nth-of-type(1) > .container > .box {
          transform: translate(-50%, -50%) rotate(-4deg);
        }

        &:nth-of-type(2) > .container > .box {
          transform: translate(-50%, -50%) rotate(4deg);
        }
      }
    }

    .content {
      padding: 5rem clamp(1rem, calc(3rem / 0.48), 5rem);
      max-width: clamp(20rem, calc(25.4vw / 0.48), 42.6875rem);

      .heading {
        margin-bottom: 1.25rem;
      }

      .paragraph {
        margin-bottom: clamp(1.25rem, calc(2.25vw / 0.48), 4rem);
        font-size: var(--typography-body-xl, 1.125rem);
        line-height: 1.5;
        font-variant-numeric: lining-nums proportional-nums;
      }

      .steps {
        .step {
          counter-increment: step;

          &:not(:last-child) {
            margin-bottom: clamp(1.5rem, calc(1.5vw / 0.48), 4rem);
          }

          &-heading {
            position: relative;
            margin-left: 2.625rem;
            background-color: var(--primary-200);
            padding: 0.375rem clamp(0.675rem, calc(1vw / 0.48), 1rem);
            border-radius: 999px;
            min-height: 3.25rem;
            display: flex;
            align-items: center;
            font-size: var(--typography-body-xl, 1.125rem);
            color: var(--neutral-400, #ffe4ca);
            line-height: 1.5;
            font-variant-numeric: lining-nums proportional-nums;
            font-family: 'Neue Haas Unica', 'Neue Haas Unica Fallback', sans-serif;
            letter-spacing: -0.03em;
            font-weight: 700;
            color: var(--primary-400, #74535e);
            background-color: var(--neutral-200, #f5f1ec);

            &::before {
              content: counter(step, decimal-leading-zero);
              position: absolute;
              top: 50%;
              transform: translateY(-50%);
              padding-top: 1px;
              left: -2.625rem;
              width: 2.25rem;
              height: 2.25rem;
              display: grid;
              place-items: center;
              border-radius: 50%;
              font-weight: 400;
              font-size: var(--typography-body-l, 1rem);
              line-height: 1.55;
              letter-spacing: -0.02em;
              background-color: var(--neutral-200, #f5f1ec);
            }
          }

          &:nth-of-type(1) {
            .step-heading {
              background-color: var(--primary-700);
              color: var(--neutral-400, #ffe4ca);

              &::before {
                background-color: var(--primary-700);
                color: var(--neutral-400, #ffe4ca);
              }
            }
          }

          &-paragraph {
            margin-top: 0.75rem;
            font-size: var(--typography-body-xl, 1.125rem);
            font-variant-numeric: lining-nums proportional-nums;
            line-height: 1.5;
            letter-spacing: -0.02em;
            padding: 0 0.375rem;

            :global(ul) {
              margin-top: clamp(1rem, calc(1rem / 0.48), 1.5rem);

              :global(li) {
                display: grid;
                grid-template-columns: auto 1fr;
                gap: 0.675rem;
                font-size: var(--typography-body-xl, 1.125rem);
                font-variant-numeric: lining-nums proportional-nums;
                line-height: 1.5;

                &:not(:last-child) {
                  margin-bottom: clamp(0.675rem, calc(0.75rem / 0.48), 0.75rem);
                }

                &::before {
                  content: '';
                  background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDE4IDE4IiBmaWxsPSJub25lIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuOTk5IDEuNjY2Yy0uMjAzLjE3My0uMzA1LjI2LS40MTMuMzMyYTIuMjYgMi4yNiAwIDAgMS0uODIuMzRjLS4xMjkuMDI2LS4yNjIuMDM2LS41MjcuMDU3LS42NjguMDU0LTEuMDAyLjA4LTEuMjguMTc5YTIuMjYgMi4yNiAwIDAgMC0xLjM4IDEuMzc4Yy0uMDk4LjI3OS0uMTI0LjYxMy0uMTc4IDEuMjhhNC43NzIgNC43NzIgMCAwIDEtLjA1Ny41MjcgMi4yNiAyLjI2IDAgMCAxLS4zNC44MjFjLS4wNzIuMTA5LS4xNTkuMjEtLjMzMi40MTMtLjQzNC41MS0uNjUyLjc2NS0uNzggMS4wMzFhMi4yNiAyLjI2IDAgMCAwIDAgMS45NWMuMTI4LjI2Ny4zNDYuNTIyLjc4IDEuMDMyLjE3My4yMDMuMjYuMzA0LjMzMi40MTIuMTY3LjI0OS4yODIuNTI4LjM0LjgyMS4wMjUuMTI4LjAzNi4yNjEuMDU3LjUyNy4wNTQuNjY4LjA4IDEuMDAyLjE3OSAxLjI4YTIuMjYgMi4yNiAwIDAgMCAxLjM3OCAxLjM3OWMuMjc5LjA5OC42MTMuMTI1IDEuMjguMTc4LjI2Ni4wMjEuNC4wMzIuNTI3LjA1Ny4yOTQuMDU4LjU3My4xNzQuODIxLjM0LjEwOC4wNzMuMjEuMTYuNDEzLjMzMi41MS40MzUuNzY1LjY1MiAxLjAzMS43OGEyLjI2IDIuMjYgMCAwIDAgMS45NSAwYy4yNjctLjEyOC41MjItLjM0NSAxLjAzMS0uNzguMjA0LS4xNzIuMzA1LS4yNTkuNDEzLS4zMzJhMi4yNiAyLjI2IDAgMCAxIC44MjEtLjM0Yy4xMjgtLjAyNS4yNjEtLjAzNi41MjctLjA1Ny42NjgtLjA1MyAxLjAwMi0uMDggMS4yOC0uMTc4YTIuMjYxIDIuMjYxIDAgMCAwIDEuMzc5LTEuMzc5Yy4wOTgtLjI3OC4xMjUtLjYxMi4xNzgtMS4yOC4wMjEtLjI2Ni4wMzItLjM5OS4wNTctLjUyN2EyLjI2IDIuMjYgMCAwIDEgLjM0LS44MmMuMDczLS4xMDkuMTYtLjIxLjMzMi0uNDEzLjQzNS0uNTEuNjUyLS43NjUuNzgtMS4wMzJhMi4yNiAyLjI2IDAgMCAwIDAtMS45NWMtLjEyOC0uMjY2LS4zNDUtLjUyMS0uNzgtMS4wMzEtLjE3My0uMjAzLS4yNi0uMzA0LS4zMzItLjQxM2EyLjI2IDIuMjYgMCAwIDEtLjM0LS44MmMtLjAyNS0uMTI5LS4wMzYtLjI2MS0uMDU3LS41MjctLjA1My0uNjY4LS4wOC0xLjAwMi0uMTc4LTEuMjhhMi4yNiAyLjI2IDAgMCAwLTEuMzc5LTEuMzhjLS4yNzgtLjA5OC0uNjEyLS4xMjQtMS4yOC0uMTc4YTQuNzczIDQuNzczIDAgMCAxLS41MjctLjA1NyAyLjI2IDIuMjYgMCAwIDEtLjgyLS4zNCA0Ljc5MyA0Ljc5MyAwIDAgMS0uNDE0LS4zMzJjLS41MS0uNDM0LS43NjQtLjY1Mi0xLjAzLS43NzlhMi4yNiAyLjI2IDAgMCAwLTEuOTUgMGMtLjI2Ny4xMjctLjUyMi4zNDUtMS4wMzIuNzhabTUuNjUgNS41NTNhLjY3OC42NzggMCAwIDAtLjk1OC0uOTZsLTQuMDQyIDQuMDQyLTEuMzMtMS4zMjlhLjY3OC42NzggMCAwIDAtLjk1OC45NmwxLjgwOCAxLjgwOGEuNjc4LjY3OCAwIDAgMCAuOTYgMGw0LjUyLTQuNTIxWiIgZmlsbD0iI0Y2NzI1OCIvPjwvc3ZnPg==')
                    center / contain no-repeat;
                  width: 1.25rem;
                  height: 1.25rem;
                  margin-top: 4px;
                }
              }
            }
          }

          .blocks {
            margin-top: clamp(1rem, calc(1rem / 0.48), 1.5rem);
            gap: 0.5rem;
            display: grid;
            grid-template-columns: repeat(2, 1fr);

            .block {
              border-radius: clamp(8px, calc(12vw / 7.68), 12px);
              background: var(--neutral-200, #f5f1ec);
              &[data-type='ctaBlock'] {
                padding: clamp(1rem, calc(1.25vw / 0.48), 1.25rem);
                a {
                  margin-bottom: 1rem;
                }
              }

              &[data-type='imageBlock'] {
                padding: clamp(0.75rem, calc(1vw / 0.48), 1rem);
              }

              .image-block {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.125rem 0.875rem 0.25rem 0.675rem;
                background: var(--primary-800, #45051c);
                border-radius: 999px;
                margin-bottom: clamp(0.75rem, calc(1.5vw / 0.48), 2rem);
                font-size: var(--typography-body-l, 1.125rem);
                line-height: 1.5;
                letter-spacing: 0.01em;
                color: var(--neutral-400, #ffe4ca);
                max-width: fit-content;
                font-variant-numeric: lining-nums proportional-nums;

                font-weight: 400;

                min-height: 2.5rem;

                :global(svg) {
                  padding-top: 2px;
                }
              }
            }
          }
        }
      }
    }

    @media (max-width: 67.4375rem) {
      grid-template-columns: 1fr;

      .columns {
        position: static;
        height: 20rem;
        width: 100%;
        max-width: 30rem;
        margin: 0 auto;
      }

      .content {
        margin: 0 auto;
        max-width: 50rem;
        padding: clamp(3rem, calc(5vw / 0.48), 5rem) var(--pageMargin) 5rem;
      }
    }

    @media (max-width: 31.1875rem) {
      .content {
        .steps {
          display: grid;
          .step {
            &-heading {
              margin-top: 2.5rem;
              margin-left: 0;
              border-radius: 8px;

              &::before {
                left: 0;
                transform: none;
                top: -2.5rem;
              }
            }

            .blocks {
              grid-template-columns: 1fr;
              max-width: 27rem;
            }
          }
        }
      }
    }
  }
</style>
