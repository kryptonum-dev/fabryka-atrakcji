---
import { getLangFromPath, type Language } from '@/src/global/languages'
import metadataFetch from '@/src/utils/metadata.fetch'
import sanityFetch from '@/src/utils/sanity.fetch'
import PortableText, { PortableTextQuery, type PortableTextValue } from '@/src/components/ui/portable-text'
import ActivityTemplate from './ActivityTemplate.astro'
import HotelTemplate from './HotelTemplate.astro'
import ExtrasTemplate from './ExtrasTemplate.astro'
import Button from '@/src/components/ui/Button'
import AddonsPopup from '@/src/components/offer/AddonsPopup.astro'
import RemoveConfirmation from '@/src/components/ui/RemoveConfirmation.astro'
import DatePicker from '@/src/components/ui/DatePicker.astro'
import AlertTemplate from './AlertTemplate.astro'
import Image, { ImageDataQuery } from '@/src/components/ui/image'
import PopupWindow from '@/src/components/ui/PopupWindow/index.astro'
import CloseButton from '@/src/components/ui/PopupWindow/CloseButton.astro'
import AddressForm from '@/src/components/cart/form'
import SkeletonLoader from '@/src/components/cart/SkeletonLoader.astro'
import type { ExtraItem } from '@/src/global/types'
import QuoteCartLayout from '@/src/layouts/QuoteCartLayout.astro'
import AdditionalInfoBlock from '@/src/components/cart/AdditionalInfoBlock.astro'
import Loader from '@/src/components/ui/Loader.astro'
type Props = NonNullable<Awaited<ReturnType<typeof fetchData>>>

export async function fetchData(lang: Language) {
  const page = await sanityFetch<{
    name: string
    slug: string
    infoParagraph: PortableTextValue
    noResults: {
      heading: PortableTextValue
      paragraph: PortableTextValue
    }
    errorState: {
      heading: PortableTextValue
      paragraph: PortableTextValue
    }
    orderAddons: {
      transportOptions: ExtraItem
      addonsList: Array<ExtraItem>
    }
  }>({
    query: `
      *[_type == "Cart_Page" && language == $language][0] {
        name,
        "slug": slug.current,
        ${PortableTextQuery('infoParagraph')}
        noResults {
          ${PortableTextQuery('heading')}
          ${PortableTextQuery('paragraph')}
        },
        errorState {
          ${PortableTextQuery('heading')}
          ${PortableTextQuery('paragraph')}
        },
        orderAddons {
          transportOptions {
            ${ImageDataQuery('image')}
            pricing {
              type,
              pricePerKm,
              fixedPrice,
              threshold {
                basePrice,
                maxUnits,
                additionalPrice,
                singular,
              },
            },
          },
          addonsList[] {
            _key,
            name,
            ${ImageDataQuery('image')}
            pricing {
              type,
              fixedPrice,
              threshold {
                basePrice,
                maxUnits,
                additionalPrice,
                singular,
              },
            },
          },
        },
      }
    `,
    params: { language: lang },
  })

  if (!page) return null

  const metadata = await metadataFetch(page.slug)

  if (!metadata) return null

  return {
    metadata,
    page,
  }
}

const lang = (getLangFromPath(Astro.url.pathname) as Language) || 'pl'

const translations = {
  pl: {
    back: {
      content: 'Wróć do przeglądania integracji i hoteli',
      url: '/pl',
    },
    cartHeading: 'Twój koszyk',
    activitiesHeading: 'Integracje',
    hotelsHeading: 'Hotele',
    extrasHeading: 'Dodaj coś ekstra',
    optional: '(opcjonalne)',
    howManyParticipants: 'Ile osób bierze udział?',
    whichDate: 'Kiedy planujecie pobyt i/lub event?',
    getQuote: {
      text: 'Otrzymaj wstępną wycenę',
      additionalInfo: 'W następnym kroku poznasz wycenę. Nie oznacza to rezerwacji hotelu ani integracji',
    },
    hotels: 'Hotele',
    hotelsPrefix: '/pl/hotele/',
    activities: 'Integracje',
    activitiesPrefix: '/pl/integracje/',
    people: 'osób',
    person: 'osoba',
    to: 'do',
    from: 'od',
    additionalPerson: 'Każda dodatkowa osoba',
    currency: 'zł',
    perNight: 'zł/noc za osobę',
    max: 'Maks.',
    addons: 'Dobierz dodatki',
    editAddons: 'Edytuj dodatki',
    transportAddonName: 'Transport',
    selectAddon: 'Wybierz',
    showMoreExtras: 'Zobacz wszystkie dodatki',
    selectExtrasHeading: 'Wybierz dodatki',
    confirmAddons: 'Zatwierdź wybór',
    allAddons: 'Wszystkie <strong>dodatki</strong>',
    missingParticipants: 'Podaj liczbę uczestników przed wysłaniem wyceny',
    missingDates: 'Musisz wybrać co najmniej jeden termin',
    emptySection: {
      hotels: {
        heading: 'Nie wybrałeś jeszcze <strong>żadnego hotelu</strong>',
        paragraph:
          'Jeśli potrzebujerz dobrać <strong>hotel do wybranych integracji</strong>, wybierz hotel z naszej oferty klikając w przycisk poniżej.',
        button: 'Przeglądaj hotele',
      },
      activities: {
        heading: 'Nie wybrałeś jeszcze <strong>żadnych integracji</strong>',
        paragraph:
          'Jeśli potrzebujerz dobrać <strong>integracje do wybranych hoteli</strong>, wybierz integracje z naszej oferty klikając w przycisk poniżej.',
        button: 'Przeglądaj integracje',
      },
    },
    addressForm: {
      transportName: 'Transport',
      formHeading: 'Skąd was odebrać?',
      title: 'Edytuj <strong>adres</strong>',
      street: 'Ulica i numer*',
      streetPlaceholder: 'np. Kwiatowa 56/23b',
      streetRequired: 'Ulica i numer są wymagane',
      postal: 'Kod pocztowy*',
      postalPlaceholder: '__ - ___',
      postalRequired: 'Kod pocztowy jest wymagany',
      postalPattern: 'Wprowadź kod w formacie: XX-XXX',
      city: 'Miasto*',
      cityRequired: 'Miasto jest wymagane',
      submit: 'Zapisz adres',
      editButton: 'Edytuj adres',
      pickFromMap: 'Wybierz z mapy',
      searchLocation: 'Szukaj lokalizacji',
      confirm: 'Zatwierdź',
      cancel: 'Anuluj',
      mapTooltip: 'Otwórz mapę, aby wybrać lokalizację',
    },
    transportRemoval: {
      title: 'Czy na pewno chcesz usunąć <strong>Transport</strong> z wyceny?',
      message: 'Usunięcie transportu spowoduje również usunięcie wprowadzonego adresu.',
      confirm: 'Tak, usuń',
      cancel: 'Anuluj',
      successToast: 'Transport został usunięty',
    },
    participantExceedsMaxAlert: {
      heading: 'Ten hotel jest maksymalnie dla <strong>{maxPeople}</strong> osób',
      paragraph: 'Możesz kontynuować wycenę albo zmienić hotel, który pomieści więcej osób.',
      cta: {
        text: 'Przeglądaj hotele',
        href: '/pl/hotele',
      },
    },
    activityParticipantBelowMinAlert: {
      heading: 'Ta integracja wymaga minimum <strong>{minPeople}</strong> osób',
      paragraph: 'Możesz kontynuować wycenę albo dostosować liczbę uczestników.',
      cta: {
        text: 'Przeglądaj integracje',
        href: '/pl/integracje',
      },
    },
    activityParticipantExceedsMaxAlert: {
      heading: 'Ta integracja jest maksymalnie dla <strong>{maxPeople}</strong> osób',
      paragraph: 'Możesz kontynuować wycenę albo zmienić integrację, która pomieści więcej osób.',
      cta: {
        text: 'Przeglądaj integracje',
        href: '/pl/integracje',
      },
    },
    states: {
      error: {
        retryButton: 'Spróbuj ponownie',
      },
      submitError: {
        heading: 'Nie udało nam się stworzyć <strong>twojej wyceny</strong>',
        paragraph: 'Wystąpił błąd podczas tworzenia wyceny. Spróbuj ponownie ponownie lub skontaktuj się z nami.',
        returnButton: 'Wróć do koszyka',
      },
      empty: {
        ctaHotels: 'Przeglądaj hotele',
        ctaActivities: 'Przeglądaj integracje',
      },
    },
  },
  en: {
    back: {
      content: 'Back to activities and hotels',
      url: '/en',
    },
    cartHeading: 'Your cart',
    activitiesHeading: 'Activities',
    hotelsHeading: 'Hotels',
    extrasHeading: 'Add something extra',
    optional: '(optional)',
    howManyParticipants: 'How many participants?',
    whichDate: 'Which date?',
    getQuote: {
      text: 'Get a quote',
      additionalInfo:
        'In the next step, you will receive a quote. This does not mean a hotel reservation or integration reservation',
    },
    hotels: 'Hotels',
    hotelsPrefix: '/en/hotels/',
    activities: 'Activities',
    activitiesPrefix: '/en/activities/',
    people: 'people',
    person: 'person',
    from: 'from',
    to: 'to',
    currency: 'PLN',
    additionalPerson: 'Each additional person',
    perNight: 'PLN/night per person',
    missingParticipants: 'Enter the number of participants before sending the quote',
    missingDates: 'You must select at least one date',
    max: 'Max.',
    addons: 'Add add-ons',
    editAddons: 'Edit add-ons',
    transportAddonName: 'Transport',
    selectAddon: 'Select',
    showMoreExtras: 'Show all extras',
    selectExtrasHeading: 'Select extras',
    confirmAddons: 'Confirm selection',
    allAddons: 'All <strong>extras</strong>',
    emptySection: {
      hotels: {
        heading: "You don't have any hotels yet",
        paragraph: 'Choose a hotel that best suits your trip needs.',
        button: 'Browse hotels',
      },
      activities: {
        heading: "You don't have any activities yet",
        paragraph: 'Choose activities that will ensure a great time during your trip.',
        button: 'Browse activities',
      },
    },
    addressForm: {
      transportName: 'Transport',
      formHeading: 'Where do you want to pick us up?',
      title: 'Edit <strong>address</strong>',
      street: 'Street and number*',
      streetPlaceholder: 'e.g. Flower 56/23b',
      streetRequired: 'Street and number are required',
      postal: 'Postal code*',
      postalPlaceholder: '__ - ___',
      postalRequired: 'Postal code is required',
      postalPattern: 'Enter code in the format: XX-XXX',
      city: 'City*',
      cityRequired: 'City is required',
      submit: 'Save address',
      editButton: 'Edit address',
      pickFromMap: 'Pick from map',
      searchLocation: 'Search location',
      confirm: 'Confirm',
      cancel: 'Cancel',
      mapTooltip: 'Open map to select location',
    },
    transportRemoval: {
      title: 'Are you sure you want to remove <strong>Transport</strong> from the quote?',
      message: 'Removing transport will also remove the address you entered.',
      confirm: 'Yes, remove',
      cancel: 'Cancel',
      successToast: 'Transport has been removed',
    },
    participantExceedsMaxAlert: {
      heading: 'This hotel is maxed out for <strong>{maxPeople}</strong> people',
      paragraph: 'You can continue with the quote or change the hotel to one that can accommodate more people.',
      cta: {
        text: 'Browse hotels',
        href: '/en/hotels',
      },
    },
    activityParticipantBelowMinAlert: {
      heading: 'This activity requires at least <strong>{minPeople}</strong> people',
      paragraph: 'You can continue with the quote or adjust the number of participants.',
      cta: {
        text: 'Browse activities',
        href: '/en/activities',
      },
    },
    activityParticipantExceedsMaxAlert: {
      heading: 'This activity is maxed out for <strong>{maxPeople}</strong> people',
      paragraph: 'You can continue with the quote or change the activity to one that can accommodate more people.',
      cta: {
        text: 'Browse activities',
        href: '/en/activities',
      },
    },
    states: {
      error: {
        retryButton: 'Try Again',
      },
      submitError: {
        heading: 'Failed to create quote',
        paragraph: 'There was an error while creating your quote. Please try again or contact us.',
        returnButton: 'Return to Cart',
      },
      empty: {
        ctaHotels: 'Browse hotels',
        ctaActivities: 'Browse activities',
      },
    },
  },
} as const

const t = translations[lang]

const { metadata, page } = Astro.props
---

<QuoteCartLayout
  backLink={{
    text: t.back.content,
    url: t.back.url,
  }}
  metadata={metadata}
  data-translations={JSON.stringify(translations[lang])}
  data-lang={lang}
  class="Cart"
>
  <div class="cart-container">
    <div class="state state-loading">
      <SkeletonLoader />
    </div>

    <div class="state state-empty" style="display: none;">
      <PortableText value={page.noResults.heading} heading="h1" />
      <PortableText value={page.noResults.paragraph} class="paragraph" />
      <div class="cta-buttons">
        <Button theme="primary" shade="light" href={t.hotelsPrefix}>{t.states.empty.ctaHotels}</Button>
        <Button theme="primary" href={t.activitiesPrefix}>{t.states.empty.ctaActivities}</Button>
      </div>
    </div>

    <div class="state state-error" style="display: none;">
      <PortableText value={page.errorState.heading} heading="h1" />
      <PortableText value={page.errorState.paragraph} class="paragraph" />
      <Button id="retry-load-cart">{t.states.error.retryButton}</Button>
    </div>

    <div class="state state-submit-loading" style="display: none;">
      <Loader />
    </div>

    <div class="state state-submit-error" style="display: none;">
      <h1><Fragment set:html={t.states.submitError?.heading} /></h1>
      <p class="paragraph">
        <Fragment set:html={t.states.submitError?.paragraph} />
      </p>
      <Button id="return-to-cart">{t.states.submitError?.returnButton}</Button>
    </div>

    <div class="state state-content items-wrapper" style="display: none;">
      <header class="header">
        <AdditionalInfoBlock additionalInfo={page.infoParagraph} />
        <h1 class="cart-heading">
          <span class="text">{t.cartHeading}</span>
          <span class="count">0</span>
        </h1>
        <div class="inputs">
          <div class="input-field participants">
            <label for="participantCount">
              <span class="label">{t.howManyParticipants}</span>
            </label>
            <div class="input-box">
              <div class="gradient"></div>
              <input
                type="number"
                id="participantCount"
                class="participant-input"
                min="1"
                step="1"
                placeholder={lang === 'pl' ? 'Dodaj wartość' : 'Add value'}
              />
            </div>
          </div>
          <DatePicker lang={lang} />
        </div>
      </header>
      <div class="hotels-section">
        <h2 class="cart-heading cart-heading-s">
          <span class="title">{t.hotelsHeading}</span>
          <span class="count">0</span>
        </h2>
        <ul class="list"></ul>
      </div>
      <div class="activities-section">
        <h2 class="cart-heading cart-heading-s">
          <span class="title">{t.activitiesHeading}</span>
          <span class="count">0</span>
        </h2>
        <ul class="list"></ul>
      </div>
      <div class="extras">
        <h2 class="cart-heading cart-heading-s">
          <span class="title">{t.extrasHeading} <strong>{t.optional}</strong></span>
          <span class="count">0</span>
        </h2>
        <ul class="list" data-addons-data={JSON.stringify(page.orderAddons)}></ul>
        <div class="show-more-wrapper">
          <Button className="show-more-extras" theme="secondary">
            {t.showMoreExtras}{' '}
            <strong>({page.orderAddons.addonsList.length + 1})</strong>
          </Button>
        </div>
      </div>
      <div class="actions">
        <Button id="get-quote-button">{t.getQuote.text}</Button>
        <p class="additional-info">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" fill="none"
            ><path
              fill="#F67258"
              fill-rule="evenodd"
              d="M6.398 2.382a3.817 3.817 0 0 1-.33.266 1.809 1.809 0 0 1-.657.272c-.103.02-.209.029-.422.046-.534.042-.801.063-1.024.142-.515.182-.92.588-1.103 1.103-.079.223-.1.49-.143 1.024-.017.213-.025.32-.045.422a1.809 1.809 0 0 1-.272.656 3.818 3.818 0 0 1-.266.33c-.348.409-.521.613-.623.826a1.809 1.809 0 0 0 0 1.56c.102.213.275.417.623.825.138.162.208.243.266.33.133.199.225.422.272.657.02.102.028.208.045.421.043.534.064.801.143 1.024.182.516.588.921 1.103 1.103.223.079.49.1 1.024.143.213.017.32.025.422.046.234.046.458.138.656.272.087.058.168.127.33.265.408.348.612.522.826.624a1.809 1.809 0 0 0 1.56 0c.213-.102.417-.276.825-.624a3.81 3.81 0 0 1 .33-.265 1.81 1.81 0 0 1 .656-.272c.103-.02.21-.03.422-.046.534-.043.801-.064 1.024-.143.516-.182.921-.587 1.103-1.103.079-.223.1-.49.143-1.024.017-.213.025-.319.046-.421.046-.235.138-.458.271-.657.059-.087.128-.168.266-.33.348-.408.521-.612.623-.825a1.809 1.809 0 0 0 0-1.56c-.102-.213-.275-.417-.623-.825a3.83 3.83 0 0 1-.266-.33 1.808 1.808 0 0 1-.271-.657c-.02-.103-.03-.209-.046-.422-.043-.534-.064-.801-.143-1.024a1.809 1.809 0 0 0-1.103-1.103c-.223-.079-.49-.1-1.024-.142a3.817 3.817 0 0 1-.421-.046 1.808 1.808 0 0 1-.657-.272 3.817 3.817 0 0 1-.33-.266c-.408-.347-.612-.521-.825-.623a1.809 1.809 0 0 0-1.56 0c-.214.102-.418.276-.825.623Zm4.52 4.442a.543.543 0 0 0-.767-.767L6.917 9.29 5.854 8.227a.543.543 0 1 0-.767.767l1.447 1.447a.543.543 0 0 0 .767 0l3.617-3.617Z"
              clip-rule="evenodd"></path></svg
          ><span>{t.getQuote.additionalInfo}</span>
        </p>
      </div>
    </div>
  </div>
</QuoteCartLayout>
<HotelTemplate />
<ActivityTemplate />
<AlertTemplate />
<ExtrasTemplate />
<AddonsPopup type="hotels" addons={{ hasAddons: true, addonsList: [] }} />
<RemoveConfirmation itemId="" itemType="hotels" hasAddons={false} lang={lang} itemName="" />
<PopupWindow>
  <Button slot="open" data-popup-id="extras-popup" className="hidden-trigger" id="extras-popup-trigger">Open</Button>
  <div slot="content" class="popup-content" data-popup-id="extras-popup-container">
    <div class="extras-container">
      <h2><Fragment set:html={t.allAddons} /></h2>
      <CloseButton />

      <div class="extras-list-wrapper">
        <ul class="extras-list"></ul>
      </div>
    </div>
  </div>
</PopupWindow>

<PopupWindow>
  <Button slot="open" className="hidden-trigger" id="transport-address-trigger">Open</Button>
  <div slot="content" class="popup-content address-popup">
    <h2><Fragment set:html={t.addressForm.title} /></h2>
    <div class="transport-box">
      <Image {...page.orderAddons.transportOptions.image} sizes="100vw" />
      <h3>{t.addressForm.transportName}</h3>
      <div class="price-info">
        <p class="price">
          {
            page.orderAddons.transportOptions.pricing.type === 'threshold' ? (
              <>
                <strong>
                  {t.from} {page.orderAddons.transportOptions.pricing.threshold.basePrice} {t.currency}
                </strong>
                <span>
                  / {t.to} {page.orderAddons.transportOptions.pricing.threshold.maxUnits} {t.people}
                </span>
              </>
            ) : (
              <strong>
                {page.orderAddons.transportOptions.pricing.fixedPrice} ${t.currency}
              </strong>
            )
          }
        </p>
        {
          page.orderAddons.transportOptions.pricing.type === 'threshold' && (
            <p class="price-details">
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" fill="none">
                <path stroke="#F67258" stroke-linecap="round" d="M9 6.963H6m0 0H3m3 0v-3m0 3v3" />
              </svg>
              <span>{t.additionalPerson}</span>
              <strong>
                {page.orderAddons.transportOptions.pricing.threshold.additionalPrice} {t.currency}
              </strong>
            </p>
          )
        }
      </div>
    </div>
    <CloseButton />
    <div class="address-form-wrapper">
      <p class="address-form-heading">{t.addressForm.formHeading}</p>
      <AddressForm client:idle translations={t.addressForm} />
    </div>
  </div>
</PopupWindow>

<PopupWindow>
  <Button slot="open" className="hidden-trigger" id="transport-remove-trigger">Open</Button>
  <div slot="content" class="popup-content removal-confirmation">
    <CloseButton />
    <p class="title"><Fragment set:html={t.transportRemoval.title} /></p>
    <p class="message">{t.transportRemoval.message}</p>
    <div class="confirmation-actions">
      <Button theme="primary" shade="light" className="cancel-transport-remove">{t.transportRemoval.cancel}</Button>
      <Button theme="primary" shade="dark" className="confirm-transport-remove">{t.transportRemoval.confirm}</Button>
    </div>
  </div>
</PopupWindow>

<style lang="scss">
  // Skeleton loader animation and base styles

  .Cart {
    padding: clamp(1rem, calc(3vw / 0.48), 4rem) 0 clamp(2rem, calc(4vw / 0.48), 4rem);
    scroll-behavior: unset;

    .cart-container {
      min-height: 30rem;
      padding: clamp(1rem, calc(2.75vw / 0.48), 2.75rem) 2.75rem;
      isolation: isolate;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;

      // State styles
      .state {
        width: 100%;
      }

      .state-loading {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 20rem;

        .loading-message {
          margin-top: 1rem;
          color: var(--primary-400);
          font-size: var(--typography-body-m, 0.875rem);
        }
      }

      .state-submit-loading {
        :global(> div) {
          background-color: transparent;
          backdrop-filter: blur(0px);
        }
      }

      .state-empty,
      .state-error,
      .state-submit-error {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        justify-content: center;
        padding: 2rem 0;

        h1,
        h2 {
          margin-bottom: 1rem;
          color: var(--primary-800);
        }

        p {
          max-width: 30rem;
          margin: 0 auto;

          :global(strong) {
            color: var(--primary-800);
            font-weight: 700;
          }
        }

        .cta-buttons {
          display: flex;
          justify-content: center;
          gap: 1rem;
          margin-top: 3rem;

          @media (max-width: 28.6875rem) {
            flex-direction: column;
            max-width: 100%;
            width: 100%;

            :global(a) {
              width: 100%;
              max-width: 100%;
              :global(span) {
                margin: 0 auto;
                padding-right: 1.75rem;
              }
            }
          }
        }

        @media (max-width: 28.6875rem) {
          text-align: start;
        }
      }
      .state-error,
      .state-submit-error {
        :global(button) {
          max-width: 20rem;
          width: 100%;
          margin: 3rem auto 0;

          :global(span) {
            margin: 0 auto;
            padding-right: 1.75rem;
          }

          @media (max-width: 28.6875rem) {
            max-width: 100%;
          }
        }
      }

      .items-wrapper {
        display: flex;
        flex-direction: column;
        gap: clamp(2rem, calc(2vw / 0.48), 2.25rem);
        .header {
          .inputs {
            margin-top: clamp(1rem, calc(1vw / 0.48), 1.5rem);
            display: flex;
            gap: 1rem;
            width: 100%;

            .input-field {
              flex: 1;
              display: flex;
              flex-direction: column;
              gap: 0.125rem;

              &.participants {
                max-width: 7.625rem;
              }

              .label {
                font-size: var(--typography-body-s, 0.75rem);
                line-height: 1.6;
                letter-spacing: -0.01em;
                color: var(--primary-800, #45051c);
              }

              .input-box {
                position: relative;
                isolation: isolate;
                background-color: var(--neutral-100, #faf7f7);
                border-radius: 0.25rem;

                &::before,
                &::after {
                  position: absolute;
                  z-index: -3;
                  inset: 0;
                  content: '';
                  background-color: var(--neutral-500, #d2c1b0);
                  border-radius: 0.25rem;
                  transition: background-color 275ms;
                }

                &::after {
                  z-index: -1;
                  inset: 0.125rem;
                  background: linear-gradient(var(--neutral-100, #faf7f7), var(--neutral-100, #faf7f7)) padding-box;
                  border-radius: 0.125rem;
                }

                &:hover::before {
                  background-color: var(--primary-400, #74535e);
                }

                .gradient {
                  position: absolute;
                  z-index: -2;
                  inset: 0;
                  overflow: hidden;
                  border-radius: 0.25rem;

                  &::before {
                    position: absolute;
                    inset: -0.0625rem;
                    content: '';
                    background: conic-gradient(
                      from 135deg at 50% 50%,
                      #798ddc 0deg,
                      #e7c78f 90deg,
                      #fa7468 266.40000343322754deg,
                      #798ddc 360deg
                    );
                    opacity: 0;
                    transform: scaleX(0);
                    transition:
                      opacity 125ms,
                      transform 475ms var(--easing);
                  }
                }

                input {
                  width: 100%;
                  min-height: 2.5rem;
                  padding: 0.625rem;
                  color: var(--primary-800, #45051c);
                  font-size: var(--typography-body-m, 0.875rem);
                  line-height: 1.4;
                  border-radius: 0.25rem;
                  border: none;
                  background: transparent;

                  &:focus-visible {
                    outline: none;
                  }

                  &::-webkit-outer-spin-button,
                  &::-webkit-inner-spin-button {
                    -webkit-appearance: none;
                    margin: 0;
                  }

                  /* Firefox */
                  &[type='number'] {
                    -moz-appearance: textfield;
                  }
                  &::placeholder {
                    font-size: var(--typography-body-m, 0.875rem);
                    color: var(--primary-400, #74535e);
                  }
                }

                &:has(input:focus-visible) {
                  .gradient {
                    &::before {
                      opacity: 1;
                      transform: scaleX(1);
                    }
                  }
                }
              }
            }
          }
        }

        .cart-heading {
          font-variant-numeric: lining-nums proportional-nums;
          font-size: var(--typography-body-2xl, 1.5rem);
          line-height: 1.25;
          font-weight: 700;
          font-family: 'Neue Haas Unica', 'Neue Haas Unica Fallback', sans-serif;
          color: var(--primary-800, #45051c);
          display: flex;
          align-items: center;
          letter-spacing: -0.04em;
          gap: 0.5rem;
          text-transform: none;

          :global(strong) {
            color: var(--primary-400, #74535e);
          }

          .count {
            display: grid;
            place-items: center;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 50%;
            background: var(--neutral-300, #faf7f7);
            font-size: var(--typography-body-l, 1rem);
            line-height: 1.55;
            letter-spacing: -0.03em;
            margin-top: 2px;
            padding-bottom: 2px;
            padding-right: 1px;
          }

          &-s {
            font-size: var(--typography-body-xl, 1.125rem);
            letter-spacing: -0.03em;
            line-height: 1.55;

            .count {
              font-size: var(--typography-body-m, 0.875rem);
              line-height: 1.7;
              letter-spacing: -0.02em;
            }
          }
        }

        .hotels-section,
        .activities-section {
          .cart-heading {
            margin-bottom: 1rem;
          }
          .list {
            display: flex;
            flex-direction: column;
            gap: clamp(0.375rem, calc(0.5vw / 0.48), 0.5rem);
          }
        }

        .hotels-section {
          padding-bottom: 0.75rem;
          border-bottom: 2px solid var(--neutral-300, #ede6de);
        }

        .extras {
          .cart-heading {
            margin-bottom: 0.75rem;
          }
          .list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            align-items: start;
          }

          .show-more-wrapper {
            margin-top: clamp(0.5rem, calc(1vw / 0.48), 1rem);
            display: flex;
            justify-content: center;
            :global(> button) {
              :global(strong) {
                color: var(--primary-400, #74535e);
              }
            }

            :global(> button:hover),
            :global(> button:focus) {
              > :global(span) strong {
                color: var(--neutral-100) !important;
              }
            }
          }
        }

        .actions {
          display: flex;
          flex-direction: column;

          :global(button) {
            max-width: 100%;
            width: 100%;
            margin-bottom: clamp(0.375rem, calc(0.5vw / 0.48), 0.5rem);

            :global(span) {
              margin: 0 auto;
              padding-right: 1.75rem;
            }

            &[data-loading='true'] {
              position: relative;
              pointer-events: none;

              &::after {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 1.25rem;
                height: 1.25rem;
                margin-top: -0.625rem;
                margin-left: -0.625rem;
                border-radius: 50%;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-top-color: white;
                animation: spin 0.8s linear infinite;
              }

              :global(span) {
                opacity: 0;
              }
            }
          }

          @keyframes spin {
            to {
              transform: rotate(360deg);
            }
          }

          .additional-info {
            gap: 0.375rem;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            font-size: var(--typography-body-m, 0.875rem);
            line-height: 1.7;
            letter-spacing: -0.01em;

            :global(svg) {
              flex-shrink: 0;
              margin-top: 4px;
            }
          }
        }
      }
    }

    @media (max-width: 57.375rem) {
      .back-link {
        margin-left: 2rem;
      }
    }

    @media (max-width: 49.9375rem) {
      .cart-container {
        padding-left: clamp(0.5rem, calc(2.75vw / 0.48), 2.75rem);
        padding-right: clamp(0.5rem, calc(2.75vw / 0.48), 2.75rem);
        .items-wrapper {
          .extras {
            .list {
              display: flex;
              flex-direction: column;
            }
          }
        }
      }
    }

    @media (max-width: 32.4375rem) {
      .cart-container .items-wrapper .header {
        .inputs {
          flex-direction: column;

          .input-field.participants {
            max-width: 100%;
          }
        }
      }
    }

    @media (max-width: 29.3125rem) {
      .back-link {
        margin-left: 1rem;
      }
      .cart-container {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
        background-color: var(--neutral-200);

        &::after,
        &::before {
          display: none;
        }

        .extras {
          .show-more-wrapper {
            :global(> button) {
              max-width: 100%;
              width: 100%;

              display: flex;
              justify-content: center;
            }
          }
        }
      }
    }
  }

  :global(.popup-content) {
    max-width: 68rem;
    padding: 2.5rem;
    .extras-container {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1.5rem;
      overflow: hidden;
    }

    :global(h2) {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
      align-self: center;
      margin-top: 0.5rem;
    }

    :global(.CloseButton) {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
    }

    :global(.extras-list-wrapper) {
      grid-column: 1 / 3;
      grid-row: 2 / 3;
      display: flex;
      flex-direction: column;
      margin-top: 1rem;
      min-height: 0;
      max-height: 32.25rem;
      overflow-y: auto;

      @media (hover: hover) and (pointer: fine) {
        padding-right: 0.125rem;

        &::-webkit-scrollbar {
          width: 0.25rem;
        }

        &::-webkit-scrollbar-track {
          background: var(--neutral-300, #ede6de);
          border-radius: 16px;
        }

        &::-webkit-scrollbar-thumb {
          background: var(--primary-400, #74535e);
          border-radius: 16px;
        }

        &::-webkit-scrollbar-thumb:hover {
          background: var(--primary-700, #600d2a);
        }
      }
    }

    :global(.extras-list) {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(14rem, 1fr));
      gap: 0.25rem;
      align-items: start;
      flex-shrink: 0;
      overflow-y: auto;
    }

    @media (max-width: 49.9375rem) {
      :global(.extras-list) {
        display: flex;
        flex-direction: column;
      }
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin) 0;
      width: 100vw !important;
    }
  }

  :global(.hidden-trigger) {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  :global(.address-popup) {
    display: grid;

    align-items: start;
    gap: 1rem 2rem;
    grid-template-columns: auto 1fr 1fr;
    h2 {
      grid-column: 1/3;
      grid-row: 1/2;
    }

    :global(.CloseButton) {
      justify-self: end;
      grid-column: 3/4;
      grid-row: 1/2;
    }

    .address-form-wrapper {
      grid-column: 2/4;
      grid-row: 2/3;
      max-width: 26.25rem;

      .address-form-heading {
        color: var(--primary-800, #45051c);
        font-size: var(--typography-body-m, 0.875rem);
        font-weight: 700;
        line-height: 1.7;
        margin-bottom: 1rem;
      }
    }

    .transport-box {
      grid-column: 1/2;
      grid-row: 2/3;
      max-width: 15.125rem;
      display: grid;
      overflow: hidden;
      border-radius: 0.375rem;
      background-color: var(--neutral-100, #faf7f7);
      border: 1px solid var(--neutral-300, #ede6de);

      :global(img) {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      :global(h3) {
        padding: 0 1rem;
        margin: 1rem 0 0.75rem;
        color: var(--primary-800, #45051c);
        font-size: var(--typography-body-m, 0.875rem);
        line-height: 1.7;
        font-weight: 700;
      }

      .price-info {
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 0.125rem;
        padding: 0 1rem 1rem 1rem;
        line-height: 1.7;
        letter-spacing: -0.01em;
        font-size: var(--typography-body-m, 0.875rem);

        :global(strong) {
          color: var(--primary-800, #45051c);
        }

        .price {
          :global(strong) {
            font-size: var(--typography-body-xl, 1.125rem);
            letter-spacing: -0.03em;
            line-height: 1.5;
          }
        }

        .price-details {
          display: flex;
          align-items: flex-start;
          gap: 0.125rem;

          :global(svg) {
            flex-shrink: 0;
            margin-top: 5px;
          }
        }
      }
    }
    @media (max-width: 54.3125rem) {
      .transport-box {
        grid-column: 1/4;
        grid-row: 2/3;
        display: grid;
        grid-template-columns: auto auto 1fr;
        width: 100%;
        max-width: 100%;
        :global(img) {
          grid-column: 1/2;
          grid-row: 1/2;
          width: 159px;
          min-height: 106px;
          height: 100%;
        }
        :global(h3) {
          grid-column: 2/3;
          grid-row: 1/2;
        }

        .price-info {
          justify-self: end;
          grid-column: 3/4;
          grid-row: 1/2;
          align-self: start;
          margin-top: 1rem;
        }
      }

      .address-form-wrapper {
        grid-column: 1/4;
        grid-row: 3/4;
        max-width: 100%;

        :global(button[data-theme='primary']) {
          width: 100%;
          max-width: 100%;
          margin-top: 0.5rem;

          :global(span) {
            margin: 0 auto;
            padding-right: 1.75rem;
          }
        }
      }
    }

    @media (max-width: 46.1875rem) {
      padding: 1.5rem;
      h2 {
        grid-column: 1/2;
      }
      .transport-box {
        grid-template-columns: 1fr auto;
        :global(img) {
          grid-column: 2/3;
          grid-row: 1/2;
          margin-top: 0.5rem;
          margin-right: 0.5rem;
          border-radius: 0.25rem;
        }
        :global(h3) {
          grid-column: 1/2;
          grid-row: 1/2;
        }

        .price-info {
          margin-top: 0.5rem;
          border-top: 0.0625rem solid var(--neutral-300, #ede6de);
          padding-top: 0.5rem;
          grid-column: 1/3;
          grid-row: 2/3;
          justify-self: stretch;
          width: 100%;
        }
      }

      .address-form-wrapper {
      }
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin);
    }
  }

  :global(.removal-confirmation) {
    max-width: 36rem;
    margin: 0 auto;
    display: flex;
    gap: 0rem;
    flex-direction: column;

    :global(.CloseButton) {
      align-self: flex-end;
      margin-bottom: 1rem;
    }

    .title {
      color: var(--primary-800);
      margin-bottom: 1.25rem;
      font-size: var(--typography-body-2xl, 1.5rem);
      line-height: 1.25;
      letter-spacing: -0.035em;
      text-align: center;

      :global(strong) {
        font-weight: 700;
      }
    }

    .message {
      text-align: center;
      margin-bottom: 1.75rem;
    }

    .confirmation-actions {
      display: flex;
      gap: 1rem;
      :global(button) {
        max-width: 100%;
        width: 100%;

        &[data-theme='primary'] {
          :global(span) {
            margin: 0 auto;
            padding-right: 1.75rem;
          }
        }
      }
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin);

      :global(.CloseButton) {
        margin-bottom: 0;
      }

      .confirmation-actions {
        flex-direction: column;
      }
    }
  }
</style>

<script>
  import type { Alert } from '@/src/global/types'
  import { cartStore } from '@/src/store/cart'
  import type { AddonItem } from '@/src/store/cart'
  import {
    renderHotel,
    renderActivity,
    renderAlerts,
    type ExtendedHotelData,
    type ExtendedActivityData,
  } from '@/src/utils/cart'
  import { optimizeImage } from '@/src/utils/optimize-images'
  import { showToast } from '@/src/utils/toast'
  import { trackEvent } from '@/src/utils/track-event'

  const cartElement = document.querySelector('.Cart')
  const pageLang = cartElement?.getAttribute('data-lang') || 'pl'
  const t = JSON.parse(cartElement?.getAttribute('data-translations') || '{}') as Record<string, any>

  // Helper to get current active state
  function getActiveState(): 'loading' | 'empty' | 'error' | 'content' {
    const states = ['loading', 'empty', 'error', 'content'] as const

    for (const state of states) {
      const stateEl = document.querySelector(`.state-${state}`) as HTMLElement | null
      if (stateEl && window.getComputedStyle(stateEl).display !== 'none') {
        return state
      }
    }

    return 'loading' // Default
  }

  // Function to update participant alerts based on current count
  function updateParticipantAlerts() {
    // Only run if content state is visible
    if (getActiveState() !== 'content') return

    const participantInput = document.getElementById('participantCount') as HTMLInputElement

    // First check if we have value in localStorage, and use that if available
    const savedCount = localStorage.getItem('cart_participant_count')
    let participantCount = 0

    if (savedCount) {
      participantCount = parseInt(savedCount)
      // Make sure the input value matches localStorage
      if (participantInput) {
        participantInput.value = savedCount
      }
    } else if (participantInput) {
      // Fallback to the input value if no localStorage value exists
      participantCount = parseInt(participantInput.value || '0')
    }

    // Find all hotel items in the cart
    const hotelItems = document.querySelectorAll('.state-content .hotel-item')

    hotelItems.forEach((item) => {
      const itemId = item.getAttribute('data-item-id')
      const maxPeople = parseInt(item.getAttribute('data-max-people') || '0')

      if (!itemId || !maxPeople) return

      const alertsList = item.querySelector('.alerts')
      if (!alertsList) return

      // Remove any existing participant alerts
      const existingAlerts = alertsList.querySelectorAll('.participant-alert')
      existingAlerts.forEach((alert) => alert.remove())

      // If count exceeds max, add a new alert
      if (participantCount > maxPeople) {
        // Create a custom alert object
        const participantAlert: Alert = {
          heading: t.participantExceedsMaxAlert.heading.replace('{maxPeople}', String(maxPeople)),
          paragraph: t.participantExceedsMaxAlert.paragraph.replace('{maxPeople}', String(maxPeople)),
          cta: {
            text: t.participantExceedsMaxAlert.cta.text,
            internalReference: {
              slug: t.participantExceedsMaxAlert.cta.href,
            } as any,
          },
        }

        // Use the exported renderAlerts function with a custom class
        renderAlerts([participantAlert], alertsList, 'participant-alert')
      }
    })

    const activityItems = document.querySelectorAll('.state-content .activity-item')

    activityItems.forEach((item) => {
      const itemId = item.getAttribute('data-item-id')
      const maxPeople = parseInt(item.getAttribute('data-max-people') || '0')
      const minPeople = parseInt(item.getAttribute('data-min-people') || '0')

      if (!itemId || !maxPeople || !minPeople) return

      const alertsList = item.querySelector('.alerts')
      if (!alertsList) return

      // Remove any existing participant alerts
      const existingAlerts = alertsList.querySelectorAll('.activity-participant-alert')
      existingAlerts.forEach((alert) => alert.remove())

      // If count exceeds max, add a new alert
      if (participantCount > maxPeople) {
        // Create a custom alert object
        const participantAlert: Alert = {
          heading: t.activityParticipantExceedsMaxAlert.heading.replace('{maxPeople}', String(maxPeople)),
          paragraph: t.activityParticipantExceedsMaxAlert.paragraph.replace('{maxPeople}', String(maxPeople)),
          cta: {
            text: t.activityParticipantExceedsMaxAlert.cta.text,
            internalReference: {
              slug: t.activityParticipantExceedsMaxAlert.cta.href,
            } as any,
          },
        }

        // Use the exported renderAlerts function with a custom class
        renderAlerts([participantAlert], alertsList, 'activity-participant-alert')
      }

      if (participantCount < minPeople) {
        const participantAlert: Alert = {
          heading: t.activityParticipantBelowMinAlert.heading.replace('{minPeople}', String(minPeople)),
          paragraph: t.activityParticipantBelowMinAlert.paragraph.replace('{minPeople}', String(minPeople)),
          cta: {
            text: t.activityParticipantBelowMinAlert.cta.text,
            internalReference: {
              slug: t.activityParticipantBelowMinAlert.cta.href,
            } as any,
          },
        }

        renderAlerts([participantAlert], alertsList, 'activity-participant-alert')
      }
    })
  }

  // Create fetch functions for hotels and activities
  async function fetchHotelData(id: string, addonIds: string[] = []) {
    try {
      const addonIdsParam = addonIds.length > 0 ? `&addonIds=${addonIds.join(',')}` : ''
      const response = await fetch(`/api/cart/hotel?id=${id}&lang=${pageLang}${addonIdsParam}`)
      if (!response.ok) throw new Error('Failed to fetch hotel data')
      return await response.json()
    } catch (error) {
      console.error('Error fetching hotel:', error)
      return null
    }
  }

  async function fetchActivityData(id: string, addonIds: string[] = []) {
    try {
      const addonIdsParam = addonIds.length > 0 ? `&addonIds=${addonIds.join(',')}` : ''
      const response = await fetch(`/api/cart/activity?id=${id}&lang=${pageLang}${addonIdsParam}`)
      if (!response.ok) throw new Error('Failed to fetch activity data')
      return await response.json()
    } catch (error) {
      console.error('Error fetching activity:', error)
      return null
    }
  }

  // Function to render all cart items
  async function renderCartItems(hotels: ExtendedHotelData[], activities: ExtendedActivityData[]) {
    const cartContent = document.querySelector('.cart-container')! as HTMLDivElement
    const cartHeadingCount = document.querySelector('.state-content .header .cart-heading .count')! as HTMLSpanElement

    if (!cartContent) return

    // Render hotels section
    const hotelsSection = cartContent.querySelector('.hotels-section')! as HTMLDivElement
    const hotelList = hotelsSection.querySelector('.list')! as HTMLDivElement
    const hotelsCount = hotelsSection.querySelector('.count')! as HTMLSpanElement

    if (hotels && hotels.length > 0) {
      const hotelPromises = hotels.map(async (hotel) => {
        const hotelElement = await renderHotel(hotel, t)
        return hotelElement
      })
      const hotelElements = await Promise.all(hotelPromises)
      hotelElements.forEach((hotelElement) => {
        if (hotelElement) {
          hotelList.appendChild(hotelElement)
        }
      })
      hotelsCount.textContent = hotels.length.toString()
    } else if (activities && activities.length > 0) {
      // If we have activities but no hotels, show the empty hotels alert
      hotelsCount.textContent = '0'
      renderEmptySectionAlert(hotelList, 'hotels')
    }

    // Render activities section
    const activitiesSection = cartContent.querySelector('.activities-section')! as HTMLDivElement
    const activitiesList = activitiesSection.querySelector('.list')! as HTMLDivElement
    const activitiesCount = activitiesSection.querySelector('.count')! as HTMLSpanElement

    if (activities && activities.length > 0) {
      const activityPromises = activities.map(async (activity) => {
        const activityElement = await renderActivity(activity, t)
        return activityElement
      })
      const activityElements = await Promise.all(activityPromises)
      activityElements.forEach((activityElement) => {
        if (activityElement) {
          activitiesList.appendChild(activityElement)
        }
      })
      activitiesCount.textContent = activities.length.toString()
    } else if (hotels && hotels.length > 0) {
      // If we have hotels but no activities, show the empty activities alert
      activitiesCount.textContent = '0'
      renderEmptySectionAlert(activitiesList, 'activities')
    }

    cartHeadingCount.textContent = `${hotels.length + activities.length}`
  }

  // Function to render empty section alerts
  function renderEmptySectionAlert(container: HTMLElement, sectionType: 'hotels' | 'activities') {
    const template = document.getElementById('alert-template') as HTMLTemplateElement
    if (!template) return

    const clone = template.content.cloneNode(true) as DocumentFragment
    const alertDiv = clone.querySelector('.alert-item') as HTMLElement

    const headingEl = alertDiv.querySelector('.alert-heading') as HTMLElement
    const paragraphEl = alertDiv.querySelector('.alert-paragraph') as HTMLElement
    const linkEl = alertDiv.querySelector('a') as HTMLAnchorElement
    const linkElText = linkEl.querySelector('span') as HTMLElement

    // Set content based on section type and translations
    headingEl.innerHTML = t.emptySection[sectionType].heading
    paragraphEl.innerHTML = t.emptySection[sectionType].paragraph

    linkEl.href = sectionType === 'hotels' ? t.hotelsPrefix : t.activitiesPrefix
    linkElText.innerHTML = t.emptySection[sectionType].button

    // Append to container
    container.appendChild(alertDiv)
  }

  // Function to rebuild the extras list in real-time
  async function refreshExtrasList(): Promise<void> {
    // Re-get everything from the beginning to ensure correct order
    await loadCartExtras()
  }

  // Function to handle transport selection
  async function handleTransportToggle(item: HTMLElement, isSelected: boolean) {
    // isSelected is the target state - if true, we're adding transport, if false, we're removing it

    // If removing transport (unchecking), show confirmation popup
    if (!isSelected) {
      // Open confirmation popup
      const transportRemoveTrigger = document.getElementById('transport-remove-trigger')

      // Store reference to the item to remove if confirmed
      localStorage.setItem('pending_transport_removal', item.dataset.addonId || '')

      // Open the popup
      if (transportRemoveTrigger) {
        transportRemoveTrigger.click()
      }

      // Don't remove yet - wait for confirmation
      return false
    }

    // If adding transport (checking), open address popup
    const transportTrigger = document.getElementById('transport-address-trigger')
    if (transportTrigger) {
      // Store current item reference for the form submission handler
      localStorage.setItem('pending_transport_item', item.dataset.addonId || '')

      transportTrigger.click()
    }

    // Don't select yet - this will happen after address submission
    return false
  }

  // Setup transport removal confirmation
  function setupTransportRemovalConfirmation() {
    const confirmBtn = document.querySelector('.confirm-transport-remove')
    const cancelBtn = document.querySelector('.cancel-transport-remove')
    const closeBtn = document.querySelector('.removal-confirmation .CloseButton')

    if (confirmBtn) {
      confirmBtn.addEventListener('click', () => {
        const pendingId = localStorage.getItem('pending_transport_removal')
        if (pendingId) {
          // Find the transport item
          const transportItem = document.querySelector(`.extra-item[data-addon-id="${pendingId}"]`) as HTMLElement

          if (transportItem) {
            // Actually remove transport
            toggleAddon(transportItem, false)

            // Remove the address data from localStorage
            localStorage.removeItem('transport_address')

            // Show toast notification with translated message
            showToast(t.transportRemoval.successToast, 'success')
          }

          // Remove pending ID
          localStorage.removeItem('pending_transport_removal')
        }

        // Close the popup
        if (closeBtn && closeBtn instanceof HTMLElement) {
          closeBtn.click()
        }
      })
    }

    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        // Reset any checkbox state that might have been visually changed
        const pendingId = localStorage.getItem('pending_transport_removal')
        if (pendingId) {
          const transportItems = document.querySelectorAll(`.extra-item[data-addon-id="${pendingId}"]`)
          transportItems.forEach((item) => {
            const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
            if (checkbox) {
              checkbox.checked = true
            }
            item.setAttribute('data-selected', 'true')
          })

          // Remove pending ID
          localStorage.removeItem('pending_transport_removal')
        }

        // Close the popup
        if (closeBtn && closeBtn instanceof HTMLElement) {
          closeBtn.click()
        }
      })
    }
  }

  // Function to update transport cards with address display
  function updateTransportCardWithAddress() {
    const transportItems = document.querySelectorAll('.extra-item[data-addon-id="transport"]')
    const addressData = JSON.parse(localStorage.getItem('transport_address') || '{}')

    transportItems.forEach((item) => {
      // Remove existing address display if any
      const existingAddress = item.querySelector('[data-address-display]')
      if (existingAddress) existingAddress.remove()

      // Only add address display if transport is selected and address exists
      const isSelected = item.getAttribute('data-selected') === 'true'
      if (!isSelected || Object.keys(addressData).length === 0) return

      // Create address display
      const addressDisplay = document.createElement('div')
      addressDisplay.setAttribute('data-address-display', '')

      const addressText = document.createElement('p')
      addressText.setAttribute('data-address-text', '')
      addressText.innerHTML = `
        <span>${addressData.street}, ${addressData.city}, (${addressData.postal})</span>
      `

      const editIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 17" fill="none"
              ><path
                fill="#F67258"
                d="M14.128 2.205a1.835 1.835 0 0 1 0 2.596l-.33.33a3.074 3.074 0 0 1-.356-.1 3.46 3.46 0 0 1-1.312-.828 3.46 3.46 0 0 1-.827-1.312 3.09 3.09 0 0 1-.1-.355l.33-.33a1.835 1.835 0 0 1 2.595 0ZM9.719 9.21c-.27.27-.404.404-.553.52a3.058 3.058 0 0 1-.565.349c-.17.081-.35.141-.712.262l-1.906.635a.495.495 0 0 1-.626-.626l.636-1.906c.12-.361.18-.542.261-.712.096-.2.213-.39.35-.565.115-.148.25-.283.52-.552L10.4 3.337a4.467 4.467 0 0 0 1.022 1.573c.538.538 1.11.847 1.573 1.022L9.72 9.21Z"
              ></path><path
                fill="#F67258"
                d="M13.69 14.025c.975-.976.975-2.548.975-5.69 0-1.033 0-1.895-.034-2.623l-4.242 4.241c-.234.235-.41.41-.608.565a4.057 4.057 0 0 1-.75.464c-.226.108-.463.186-.777.291l-1.954.652a1.495 1.495 0 0 1-1.891-1.891l.651-1.955c.105-.314.184-.55.292-.777.126-.266.282-.517.463-.75.155-.198.33-.374.565-.608l4.241-4.241c-.727-.035-1.59-.035-2.622-.035-3.143 0-4.714 0-5.69.976-.977.977-.977 2.548-.977 5.69 0 3.143 0 4.715.976 5.691.977.976 2.548.976 5.69.976 3.143 0 4.715 0 5.691-.976Z"
              ></path></svg
            >`

      const editButton = document.createElement('button')
      editButton.setAttribute('data-edit-address-button', '')
      editButton.innerHTML = `<div>${editIcon} ${editIcon}</div>  <span>${t.addressForm.editButton}</span>`
      editButton.addEventListener('click', (e) => {
        e.stopPropagation()
        // Open popup to edit address
        document.getElementById('transport-address-trigger')?.click()
      })

      // Add edit button first, then address text
      addressDisplay.appendChild(editButton)
      addressDisplay.appendChild(addressText)

      // Add to item after price info
      item.appendChild(addressDisplay)
    })
  }

  // Listen for the custom event from the React form
  document.addEventListener('address-form-submitted', (event: Event) => {
    const customEvent = event as CustomEvent
    const data = customEvent.detail?.data

    if (!data) return

    // Get pending transport item and select it
    const pendingItemId = localStorage.getItem('pending_transport_item')
    if (pendingItemId) {
      // Find all transport items (both in main list and popup)
      const transportItems = document.querySelectorAll(
        `.extra-item[data-addon-id="${pendingItemId}"]`
      ) as NodeListOf<HTMLElement>

      transportItems.forEach((item) => {
        // Update the item's state
        const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
        if (checkbox) {
          checkbox.checked = true
        }
        item.dataset.selected = 'true'

        // If this is the main list item, call toggleAddon on it
        if (!item.dataset.inPopup) {
          toggleAddon(item, true)
        }
      })

      localStorage.removeItem('pending_transport_item')
    }

    // Update transport card to show address with delay
    setTimeout(() => {
      updateTransportCardWithAddress()
    }, 200)
  })

  // Setup address form events
  function setupAddressForm() {
    // No need to do anything here as the React component handles everything
  }

  // Setup state management and retry button
  function setupStateManagement() {
    // Setup retry button
    const retryButton = document.getElementById('retry-load-cart')
    if (retryButton) {
      retryButton.addEventListener('click', () => {
        showState('loading')
        loadCartItems(true) // Pass true to indicate this is a retry
      })
    }

    // Add navigation buttons to empty state buttons if needed
    const emptyStateButtons = document.querySelectorAll('.state-empty .cta-buttons button') as NodeListOf<HTMLElement>
    emptyStateButtons.forEach((btn) => {
      if (btn.hasAttribute('href')) {
        btn.addEventListener('click', () => {
          const href = btn.getAttribute('href')
          if (href) {
            window.location.href = href
          }
        })
      }
    })
  }

  // Participant count handling
  function initParticipantInput() {
    const participantInput = document.getElementById('participantCount') as HTMLInputElement
    if (!participantInput) return

    // Load saved value from localStorage if available
    const savedCount = localStorage.getItem('cart_participant_count')
    if (savedCount) {
      participantInput.value = savedCount
    }

    // Handle input changes
    participantInput.addEventListener('input', () => {
      // Clean input - remove non-numeric values
      let value = participantInput.value.replace(/[^\d]/g, '')

      // Ensure value is at least 1
      if (!value || parseInt(value) < 1) {
        value = value || '' // Keep empty if it was empty
      }

      // Update input value
      participantInput.value = value

      // Only store in localStorage if we have a value
      if (value) {
        localStorage.setItem('cart_participant_count', value)
      } else {
        // If the field was cleared, remove from localStorage
        localStorage.removeItem('cart_participant_count')
      }

      // Update alerts when participant count changes
      updateParticipantAlerts()
    })

    // Handle blur to format value properly
    participantInput.addEventListener('blur', () => {
      let value = participantInput.value

      if (value) {
        // Convert to integer
        const intValue = parseInt(value)

        // Update with parsed integer value
        if (!isNaN(intValue)) {
          participantInput.value = intValue.toString()
          localStorage.setItem('cart_participant_count', intValue.toString())

          // Update alerts on blur
          updateParticipantAlerts()
        }
      }
    })
  }

  // Setup quote request handling
  function setupQuoteRequestHandling() {
    const getQuoteButton = document.getElementById('get-quote-button')
    const returnToCartButton = document.getElementById('return-to-cart')

    if (returnToCartButton) {
      returnToCartButton.addEventListener('click', () => {
        showState('content')
      })
    }

    if (!getQuoteButton) return

    getQuoteButton.addEventListener('click', async () => {
      try {
        // Get selected date(s)
        const cartDates = localStorage.getItem('cart_dates')
        let selectedDates: any[] = []
        if (cartDates) {
          try {
            selectedDates = JSON.parse(cartDates)
          } catch (e) {
            console.error('Error parsing cart dates:', e)
          }
        }

        // Validate that at least one date is selected
        if (!selectedDates || selectedDates.length === 0) {
          // Show error toast if no dates selected
          showToast(t.missingDates, 'error')
          return // Stop execution, don't proceed with API call
        }

        // Get participant count and validate
        const participantInput = document.getElementById('participantCount') as HTMLInputElement
        const participantCount = participantInput?.value ? parseInt(participantInput.value) : 0

        // Validate that participant count is not empty
        if (!participantCount) {
          showToast(t.missingParticipants, 'error')
          return
        }

        // Track begin_checkout event
        const { items, totalValue, itemCount } = getCartItemsForTracking()

        trackEvent({
          event_name: 'begin_checkout',
          meta: {
            event_name: 'InitiateCheckout',
            content_name: document.title,
          },
          ecommerce: {
            items: items,
            currency: 'PLN',
            value: totalValue,
            num_items: itemCount,
            participant_count: participantCount,
          },
        })

        // Scroll to top immediately when clicking submit
        window.scrollTo({
          top: 0,
          behavior: 'instant',
        })

        // Show submit-loading state
        showState('submit-loading')

        // Get cart data
        const cart = cartStore.get()

        // Fetch complete data for hotels with pricing and addons
        let validHotels = []
        let validActivities = []

        // If all necessary data is already in cache, use it
        if (cachedCartData.isComplete()) {
          validHotels = cachedCartData.hotels.map((hotel) => {
            // Format the hotel data for quote
            const addons =
              hotel.cartAddons?.map((addon) => {
                return {
                  id: addon.id,
                  name: addon.fullData?.name || 'Unknown',
                  pricing: addon.fullData?.pricing,
                  count: addon.count || 1,
                }
              }) || []

            return {
              id: hotel._id,
              type: 'hotel',
              name: hotel.name,
              slug: hotel.slug,
              pricing: hotel.pricing,
              maxPeople: hotel.maxPeople,
              addons,
              address: hotel.address,
            }
          })

          validActivities = cachedCartData.activities.map((activity) => {
            // Format the activity data for quote
            const addons =
              activity.cartAddons?.map((addon) => {
                return {
                  id: addon.id,
                  name: addon.fullData?.name || 'Unknown',
                  pricing: addon.fullData?.pricing,
                  count: addon.count || 1,
                }
              }) || []

            return {
              id: activity._id,
              type: 'activity',
              name: activity.name,
              slug: activity.slug,
              pricing: activity.pricing,
              participantsCount: activity.participantsCount,
              addons,
            }
          })
        } else {
          // If cache is not complete, fetch data (this is a backup but shouldn't happen)

          // Fetch hotels data
          const hotelsPromises = cart.hotels.map(async (hotelItem) => {
            const addonIds = hotelItem.addOns.map((addon) => addon.id)
            const hotelData = await fetchHotelData(hotelItem.id, addonIds)

            if (!hotelData) return null

            // Map addons with their counts from the cart
            const addons =
              hotelData.addons?.addonsList?.map((addon: any) => {
                const cartAddon = hotelItem.addOns.find((a: { id: string }) => a.id === addon._key)
                return {
                  id: addon._key,
                  name: addon.name,
                  pricing: addon.pricing,
                  count: cartAddon?.count || 1,
                }
              }) || []

            return {
              id: hotelItem.id,
              type: 'hotel',
              name: hotelData.name,
              slug: hotelData.slug,
              pricing: hotelData.pricing,
              maxPeople: hotelData.maxPeople,
              addons,
            }
          })

          // Fetch activities data
          const activitiesPromises = cart.activities.map(async (activityItem) => {
            const addonIds = activityItem.addOns.map((addon) => addon.id)
            const activityData = await fetchActivityData(activityItem.id, addonIds)

            if (!activityData) return null

            // Map addons with their counts from the cart
            const addons =
              activityData.addons?.addonsList?.map((addon: any) => {
                const cartAddon = activityItem.addOns.find((a: { id: string }) => a.id === addon._key)
                return {
                  id: addon._key,
                  name: addon.name,
                  pricing: addon.pricing,
                  count: cartAddon?.count || 1,
                }
              }) || []

            return {
              id: activityItem.id,
              type: 'activity',
              name: activityData.name,
              slug: activityData.slug,
              pricing: activityData.pricing,
              participantsCount: activityData.participantsCount,
              addons,
            }
          })

          // Wait for all fetch operations to complete
          const [hotels, activities] = await Promise.all([Promise.all(hotelsPromises), Promise.all(activitiesPromises)])

          // Filter out null values (failed fetches)
          validHotels = hotels.filter(Boolean)
          validActivities = activities.filter(Boolean)
        }

        // Get transport address if exists
        const transportAddress = JSON.parse(localStorage.getItem('transport_address') || 'null')

        // Get extras/addons
        const extrasIds = JSON.parse(localStorage.getItem('cart_order_addons') || '[]') as Array<{
          id: string
          count?: number
        }>

        // Get the extras data from the DOM that contains pricing information
        const extrasList = document.querySelector('.extras .list')
        const extrasData = JSON.parse(extrasList?.getAttribute('data-addons-data') || '{}')

        // Map the extras with their pricing data
        const extrasWithPricing = extrasIds.map((item: { id: string; count?: number }) => {
          if (item.id === 'transport') {
            return {
              id: item.id,
              count: item.count || 1,
              name: t.transportAddonName,
              pricing: extrasData.transportOptions.pricing,
              address: transportAddress,
            }
          } else {
            // Find the addon in the list
            const addonData = extrasData.addonsList.find(
              (addon: { _key: string; name: string; pricing: any }) => addon._key === item.id
            )
            return {
              id: item.id,
              count: item.count || 1,
              name: addonData?.name || 'Unknown Addon',
              pricing: addonData?.pricing || null,
            }
          }
        })

        // Prepare data payload
        const quoteData = {
          hotels: validHotels,
          activities: validActivities,
          participantCount,
          selectedDates,
          extras: extrasWithPricing,
          language: pageLang,
        }

        // Add artificial delay for testing
        await new Promise((resolve) => setTimeout(resolve, 200))

        // Send data to API
        const response = await fetch('/api/quotes', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(quoteData),
        })

        const result = await response.json()

        if (!result.success) {
          throw new Error(result.error || 'Failed to create quote')
        }

        // Redirect to quote page
        window.location.href = `/${pageLang}/koszyk?id=${result.quoteId}`
      } catch (error) {
        console.error('Error creating quote:', error)

        // Show submit-error state
        showState('submit-error')
      }
    })
  }

  // Initialize document event listeners
  document.addEventListener('DOMContentLoaded', () => {
    // Setup state management first
    setupStateManagement()

    // Initialize participant input to ensure it has the correct value from localStorage
    initParticipantInput()

    // Setup address form
    setupAddressForm()

    // Setup extras popup events
    setupExtrasPopupEvents()

    // Setup transport removal confirmation
    setupTransportRemovalConfirmation()

    // Setup quote request handling
    setupQuoteRequestHandling()

    // Track cart view once when the cart loads
    document.addEventListener('cart-loaded', () => {
      const cart = cartStore.get()

      // Only track if cart has items
      if (cart.hotels.length > 0 || cart.activities.length > 0) {
        const { items } = getCartItemsForTracking()

        // Track the view_cart event
        trackEvent({
          event_name: 'view_cart',
          meta: {
            content_name: document.title,
          },
          ecommerce: {
            items: items,
            currency: 'PLN',
          },
        })
      }
    })

    // Then load cart items
    loadCartItems()
  })

  // Helper function to get cart items for tracking events
  function getCartItemsForTracking() {
    const items: any[] = []

    // Add hotels to tracking
    cachedCartData.hotels.forEach((hotel) => {
      items.push({
        item_id: hotel._id,
        item_name: hotel.name,
        item_category: 'hotel',
        price: hotel.pricing?.pricePerPerson,
        quantity: 1,
      })
    })

    // Add activities to tracking
    cachedCartData.activities.forEach((activity) => {
      items.push({
        item_id: activity._id,
        item_name: activity.name,
        item_category: 'activity',
        price: activity.pricing?.basePrice,
        quantity: 1,
      })
    })

    // Add extras to tracking
    const extrasIds = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')
    if (extrasIds.length > 0) {
      const extrasList = document.querySelector('.extras .list')
      if (extrasList) {
        const extrasData = JSON.parse(extrasList.getAttribute('data-addons-data') || '{}')

        extrasIds.forEach((item: { id: string; count?: number }) => {
          if (item.id === 'transport') {
            items.push({
              item_id: 'transport',
              item_name: t.transportAddonName,
              item_category: 'extra',
              quantity: item.count || 1,
            })
          } else {
            const addonData = extrasData.addonsList.find(
              (addon: { _key: string; name: string }) => addon._key === item.id
            )
            if (addonData) {
              items.push({
                item_id: addonData._key,
                item_name: addonData.name,
                item_category: 'extra',
                quantity: item.count || 1,
              })
            }
          }
        })
      }
    }

    // Calculate total value
    let totalValue = 0
    items.forEach((item) => {
      if (item.price && item.quantity) {
        totalValue += item.price * item.quantity
      }
    })

    return {
      items,
      totalValue: totalValue > 0 ? totalValue : undefined,
      itemCount: items.length,
    }
  }

  // Modified toggleAddon to update transport address display and refresh popup list
  async function toggleAddon(item: HTMLElement, isSelected: boolean) {
    // Update data attribute
    item.dataset.selected = isSelected.toString()

    // Get addon ID
    const addonId = item.dataset.addonId
    if (!addonId) return

    // Update the checkbox to match the selected state
    const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
    if (checkbox) {
      checkbox.checked = isSelected
    }

    // Update localStorage
    updateOrderAddons(addonId, isSelected)

    // Find and update all instances of this addon (both in main list and popup)
    document.querySelectorAll(`.extra-item[data-addon-id="${addonId}"]`).forEach((element) => {
      element.setAttribute('data-selected', isSelected.toString())
      const elementCheckbox = element.querySelector('input[type="checkbox"]') as HTMLInputElement
      if (elementCheckbox) {
        elementCheckbox.checked = isSelected
      }
    })

    // Update show more button visibility
    const showMoreWrapper = document.querySelector('.show-more-wrapper') as HTMLElement
    if (showMoreWrapper) {
      const allAddons = document.querySelectorAll('.extras .list .extra-item')
      const selectedAddons = document.querySelectorAll('.extras .list .extra-item[data-selected="true"]')

      // Show the button if not all addons are selected
      if (selectedAddons.length < allAddons.length) {
        showMoreWrapper.style.display = 'flex'
      } else {
        showMoreWrapper.style.display = 'none'
      }
    }

    // Special handling for transport
    if (addonId === 'transport') {
      // If deselecting, remove address from localStorage
      if (!isSelected) {
        localStorage.removeItem('transport_address')
      }

      // Update address display for transport with a delay to ensure the DOM is ready
      setTimeout(() => {
        updateTransportCardWithAddress()
      }, 100)
    }

    // Refresh the popup list if it's open
    const popupContainer = document.querySelector(
      '.popup-content[data-popup-id="extras-popup-container"]'
    ) as HTMLElement
    if (popupContainer && popupContainer.offsetParent !== null) {
      // Check if popup is visible
      // Get all addons data from the main list
      const extrasData = JSON.parse(document.querySelector('.extras .list')?.getAttribute('data-addons-data') || '{}')

      // Create a combined list of all addons
      const allAddons: Array<{
        _key: string
        name: string
        image: any
        pricing: any
      }> = []

      // Add transport option
      if (extrasData.transportOptions) {
        allAddons.push({
          _key: 'transport',
          name: t.transportAddonName,
          image: extrasData.transportOptions.image,
          pricing: extrasData.transportOptions.pricing,
        })
      }

      // Add regular addons from Sanity
      if (extrasData.addonsList && Array.isArray(extrasData.addonsList)) {
        allAddons.push(...extrasData.addonsList)
      }

      // Get current selections from localStorage
      const currentSelectedAddons: Array<{ id: string; count?: number }> = JSON.parse(
        localStorage.getItem('cart_order_addons') || '[]'
      )

      // Sort addons - selected first
      const sortedAddons = [...allAddons].sort((a, b) => {
        const aSelected = currentSelectedAddons.some((item) => item.id === a._key) ? 1 : 0
        const bSelected = currentSelectedAddons.some((item) => item.id === b._key) ? 1 : 0
        return bSelected - aSelected // Descending order (selected first)
      })

      // Refresh the popup without closing and reopening it
      refreshPopupList(sortedAddons)
    }

    // Completely rebuild the addon list to ensure correct order
    await refreshExtrasList()
  }

  // Function to refresh the popup list without closing/reopening
  async function refreshPopupList(sortedAddons: Array<{ _key: string; name: string; image: any; pricing: any }>) {
    const extrasList = document.querySelector('.popup-content[data-popup-id="extras-popup-container"] .extras-list')
    if (!extrasList) return

    // Save scroll position
    const scrollPosition = extrasList.scrollTop

    // Clear content
    extrasList.innerHTML = ''

    // Get the latest addon selections from localStorage
    const currentSelectedAddons: Array<{ id: string; count?: number }> = JSON.parse(
      localStorage.getItem('cart_order_addons') || '[]'
    )

    // Rebuild the list with the sorted addons
    for (const addon of sortedAddons) {
      // Find existing element in the main list
      const existingElement = document.querySelector(
        `.extra-item[data-addon-id="${addon._key}"]:not([data-in-popup="true"])`
      ) as HTMLElement

      if (existingElement) {
        // Clone the existing element without event listeners
        const clonedElement = existingElement.cloneNode(true) as HTMLElement

        // Update selected state if needed
        const isSelected = currentSelectedAddons.some((item) => item.id === addon._key)
        const checkboxElem = clonedElement.querySelector('input[type="checkbox"]') as HTMLInputElement
        if (checkboxElem) {
          checkboxElem.checked = isSelected
        }
        clonedElement.dataset.selected = isSelected.toString()
        clonedElement.dataset.inPopup = 'true'

        extrasList.appendChild(clonedElement)
      } else {
        // If element doesn't exist yet (not in initial 6), create a new one
        const newIsSelected = currentSelectedAddons.some((item) => item.id === addon._key)
        const extraElement = await renderExtra(addon, newIsSelected, true)
        if (extraElement) {
          extrasList.appendChild(extraElement)
        }
      }
    }

    // Restore scroll position
    extrasList.scrollTop = scrollPosition
  }

  // Function to open addons popup with pre-sorted items
  async function openAddonsPopup(sortedAddons: Array<{ _key: string; name: string; image: any; pricing: any }>) {
    // Clear the template popup list first - this is what will be used when the popup opens
    const popupTemplateList = document.querySelector(
      '.popup-content[data-popup-id="extras-popup-container"] .extras-list'
    )
    if (popupTemplateList) {
      popupTemplateList.innerHTML = ''

      // Get current selections
      const currentSelectedAddons = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')

      // Pre-populate with sorted addons
      for (const addon of sortedAddons) {
        const isSelected = currentSelectedAddons.some((item: any) => item.id === addon._key)
        const extraElement = await renderExtra(addon, isSelected, true)
        if (extraElement) {
          popupTemplateList.appendChild(extraElement)
        }
      }
    }

    // Now trigger the popup - it will already have sorted content
    const popupTrigger = document.getElementById('extras-popup-trigger')
    if (popupTrigger) {
      popupTrigger.click()
    }
  }

  // Modify renderExtra to handle transport special case - Fix address display insertion
  async function renderExtra(
    extra: {
      _key: string
      name: string
      image: any
      pricing: {
        type: string
        fixedPrice?: number
        threshold?: {
          basePrice: number
          maxUnits: number
          additionalPrice: number
          singular: string
        }
      }
    },
    isSelected: boolean = false,
    inPopup: boolean = false
  ): Promise<HTMLElement | null> {
    const templateElement = document.getElementById('extras-template') as HTMLTemplateElement | null
    if (!templateElement) return null

    const clone = templateElement.content.cloneNode(true) as DocumentFragment
    const item = clone.querySelector('.extra-item') as HTMLElement
    if (inPopup) {
      item.dataset.inPopup = 'true'
    }

    // Set data attributes
    item.dataset.addonId = extra._key
    item.dataset.selected = isSelected.toString()

    // Setup image
    if (extra.image) {
      const imgWrapper = item.querySelector('.img-wrapper')!
      const optimizedImage = await optimizeImage({
        image: extra.image.asset.url,
        width: extra.image.asset.metadata.dimensions.width,
        height: extra.image.asset.metadata.dimensions.height,
      })

      const img = document.createElement('img')
      img.src = optimizedImage.src
      img.srcset = optimizedImage.srcSet.attribute
      img.sizes = ''
      img.alt = extra.name
      img.loading = 'lazy'
      imgWrapper.appendChild(img)
    }

    // Set name and price
    const nameElement = item.querySelector('.name')!
    nameElement.textContent = extra.name

    const priceElement = item.querySelector('.price')!
    const priceDetailsElement = item.querySelector('.price-details')!

    const plusIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" fill="none"><path stroke="#F67258" stroke-linecap="round" d="M9 6.963H6m0 0H3m3 0v-3m0 3v3"/></svg>`

    // Handle different pricing types
    if (extra.pricing.type === 'fixed' && extra.pricing.fixedPrice) {
      priceElement.innerHTML = `<strong>${extra.pricing.fixedPrice} ${t.currency}</strong>`
      priceDetailsElement.textContent = ''
    } else if (extra.pricing.type === 'threshold' && extra.pricing.threshold) {
      const { basePrice, maxUnits, additionalPrice } = extra.pricing.threshold
      priceElement.innerHTML = `<strong>${t.from} ${basePrice} ${t.currency}</strong><span>/ ${t.to} ${maxUnits} ${t.people}</span>`
      priceDetailsElement.innerHTML = `${plusIcon} <span>${t.additionalPerson}</span><strong>${additionalPrice} ${t.currency}</strong>`
    }

    // Setup checkbox
    const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
    if (checkbox) {
      checkbox.checked = isSelected

      // Add event listeners only if not in popup
      if (!inPopup) {
        // Special handling for transport
        if (extra._key === 'transport') {
          checkbox.addEventListener('change', async (e) => {
            e.stopPropagation()
            e.preventDefault() // Prevent default to handle manually

            // Determine the target state - if checkbox is currently checked, we want to uncheck (remove)
            // If it's unchecked, we want to check (add)
            const targetState = checkbox.checked
            await handleTransportToggle(item, targetState)
          })

          item.addEventListener('click', async (e) => {
            if (e.target === checkbox || (checkbox && checkbox.contains(e.target as Node))) {
              return
            }
            e.preventDefault()

            // Toggle from current state - if item is selected, the target state is unselected
            const currentState = item.dataset.selected === 'true'
            await handleTransportToggle(item, !currentState)
          })

          item.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault()

              // Toggle from current state
              const currentState = item.dataset.selected === 'true'
              await handleTransportToggle(item, !currentState)
            }
          })
        } else {
          // Regular addons
          checkbox.addEventListener('change', async (e) => {
            e.stopPropagation()
            await toggleAddon(item, checkbox.checked)
          })

          item.addEventListener('click', async (e) => {
            if (e.target === checkbox || (checkbox && checkbox.contains(e.target as Node))) {
              return
            }
            checkbox.checked = !checkbox.checked
            await toggleAddon(item, checkbox.checked)
          })

          item.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault()
              checkbox.checked = !checkbox.checked
              await toggleAddon(item, checkbox.checked)
            }
          })
        }
      }
    }

    // If it's a transport item and is selected, add address display
    if (extra._key === 'transport' && isSelected) {
      const addressData = JSON.parse(localStorage.getItem('transport_address') || '{}')
      if (Object.keys(addressData).length > 0) {
        // Create address display
        const addressDisplay = document.createElement('div')
        addressDisplay.setAttribute('data-address-display', '')

        const addressText = document.createElement('p')
        addressText.setAttribute('data-address-text', '')
        addressText.innerHTML = `
          <span>${addressData.street}, ${addressData.city}, (${addressData.postal})</span>
        `

        const editIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 17" fill="none"
              ><path
                fill="#F67258"
                d="M14.128 2.205a1.835 1.835 0 0 1 0 2.596l-.33.33a3.074 3.074 0 0 1-.356-.1 3.46 3.46 0 0 1-1.312-.828 3.46 3.46 0 0 1-.827-1.312 3.09 3.09 0 0 1-.1-.355l.33-.33a1.835 1.835 0 0 1 2.595 0ZM9.719 9.21c-.27.27-.404.404-.553.52a3.058 3.058 0 0 1-.565.349c-.17.081-.35.141-.712.262l-1.906.635a.495.495 0 0 1-.626-.626l.636-1.906c.12-.361.18-.542.261-.712.096-.2.213-.39.35-.565.115-.148.25-.283.52-.552L10.4 3.337a4.467 4.467 0 0 0 1.022 1.573c.538.538 1.11.847 1.573 1.022L9.72 9.21Z"
              ></path><path
                fill="#F67258"
                d="M13.69 14.025c.975-.976.975-2.548.975-5.69 0-1.033 0-1.895-.034-2.623l-4.242 4.241c-.234.235-.41.41-.608.565a4.057 4.057 0 0 1-.75.464c-.226.108-.463.186-.777.291l-1.954.652a1.495 1.495 0 0 1-1.891-1.891l.651-1.955c.105-.314.184-.55.292-.777.126-.266.282-.517.463-.75.155-.198.33-.374.565-.608l4.241-4.241c-.727-.035-1.59-.035-2.622-.035-3.143 0-4.714 0-5.69.976-.977.977-.977 2.548-.977 5.69 0 3.143 0 4.715.976 5.691.977.976 2.548.976 5.69.976 3.143 0 4.715 0 5.691-.976Z"
              ></path></svg
            >`

        const editButton = document.createElement('button')
        editButton.setAttribute('data-edit-address-button', '')
        editButton.innerHTML = `<div>${editIcon} ${editIcon}</div>  <span>${t.addressForm.editButton}</span>`
        editButton.addEventListener('click', (e) => {
          e.stopPropagation()
          // Open popup to edit address
          document.getElementById('transport-address-trigger')?.click()
        })

        // Add edit button first, then address text
        addressDisplay.appendChild(editButton)
        addressDisplay.appendChild(addressText)

        // Add to item after price info
        item.appendChild(addressDisplay)
      }
    }

    return item
  }

  // Modify extras popup handling for transport items
  function setupExtrasPopupEvents() {
    const extrasList = document.querySelector('.extras-list')
    if (!extrasList) return

    extrasList.addEventListener('click', async (e) => {
      const target = e.target as HTMLElement
      const addonItem = target.closest('.extra-item') as HTMLElement

      if (!addonItem) return

      // Only handle items in the popup
      if (addonItem.dataset.inPopup !== 'true') return

      // Get checkbox element inside the addon item
      const checkbox = addonItem.querySelector('input[type="checkbox"]') as HTMLInputElement
      if (!checkbox) return

      // Don't handle if click was on the checkbox itself (it will be handled naturally)
      if (target === checkbox || checkbox.contains(target as Node)) return

      // Get addon ID and current selection state
      const addonId = addonItem.dataset.addonId
      const isCurrentlySelected = addonItem.dataset.selected === 'true'

      // Special handling for transport in popup
      if (addonId === 'transport') {
        e.preventDefault()
        e.stopPropagation()

        // Instead of closing the extras popup, keep it open and just open the transport form on top
        if (!isCurrentlySelected) {
          // Adding transport
          localStorage.setItem('pending_transport_item', addonId)
          document.getElementById('transport-address-trigger')?.click()
        } else {
          // Removing transport
          localStorage.setItem('pending_transport_removal', addonId)
          document.getElementById('transport-remove-trigger')?.click()
        }
        return
      }

      // Handle regular addons in popup
      e.preventDefault()
      e.stopPropagation()

      // Toggle the checkbox visually
      checkbox.checked = !isCurrentlySelected

      // Find the corresponding addon in the main list - we need this to trigger its logic
      const mainListAddon = document.querySelector(
        `.extra-item[data-addon-id="${addonId}"]:not([data-in-popup="true"])`
      ) as HTMLElement

      if (mainListAddon) {
        // Use the existing toggleAddon function with the main list item
        await toggleAddon(mainListAddon, !isCurrentlySelected)
      } else {
        // If not found in main list, use the current popup item
        await toggleAddon(addonItem, !isCurrentlySelected)
      }

      // Update the current popup item's state to match
      addonItem.dataset.selected = (!isCurrentlySelected).toString()
      checkbox.checked = !isCurrentlySelected
    })

    // Handle checkbox clicks directly in the popup
    extrasList.addEventListener('change', async (e) => {
      const target = e.target as HTMLElement
      if (target.tagName !== 'INPUT' || (target as HTMLInputElement).type !== 'checkbox') return

      const addonItem = target.closest('.extra-item') as HTMLElement
      if (!addonItem || addonItem.dataset.inPopup !== 'true') return

      const addonId = addonItem.dataset.addonId
      const checkbox = target as HTMLInputElement
      const isSelected = checkbox.checked

      // Special handling for transport checkbox
      if (addonId === 'transport') {
        e.preventDefault()
        e.stopPropagation()

        // Prevent default checkbox behavior as we'll handle it ourselves
        checkbox.checked = !isSelected // Revert the checkbox state temporarily

        // Instead of closing the extras popup, keep it open and just open the transport dialogue on top
        if (!isSelected) {
          // If attempting to select (add) transport
          localStorage.setItem('pending_transport_item', addonId)
          document.getElementById('transport-address-trigger')?.click()
        } else {
          // If attempting to deselect (remove) transport
          localStorage.setItem('pending_transport_removal', addonId)
          document.getElementById('transport-remove-trigger')?.click()
        }

        return
      }

      // For regular addons - find the main list item
      const mainListAddon = document.querySelector(
        `.extra-item[data-addon-id="${addonId}"]:not([data-in-popup="true"])`
      ) as HTMLElement

      if (mainListAddon) {
        await toggleAddon(mainListAddon, isSelected)
      } else {
        await toggleAddon(addonItem, isSelected)
      }

      // Update current popup item to match
      addonItem.dataset.selected = isSelected.toString()
    })
  }

  // Function to update order addons in localStorage
  function updateOrderAddons(addonId: string, isSelected: boolean): void {
    let orderAddons: Array<{ id: string; count?: number }> = JSON.parse(
      localStorage.getItem('cart_order_addons') || '[]'
    )

    if (isSelected) {
      // Add if not already in the list
      if (!orderAddons.some((addon) => addon.id === addonId)) {
        orderAddons.push({ id: addonId, count: 1 })
      }
    } else {
      // Remove if in the list
      orderAddons = orderAddons.filter((addon) => addon.id !== addonId)
    }

    localStorage.setItem('cart_order_addons', JSON.stringify(orderAddons))

    // Update count displayed
    updateExtrasCount()

    // Dispatch event for other components that might need to know
    document.dispatchEvent(
      new CustomEvent('order-addons-updated', {
        detail: { addons: orderAddons },
      })
    )
  }

  // Function to update the extras count display
  function updateExtrasCount(): void {
    const orderAddons = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')
    const countElement = document.querySelector('.extras .count')
    if (countElement) {
      // Transport is no longer automatically included
      countElement.textContent = orderAddons.length.toString()
    }
  }

  // Function to load cart extras
  async function loadCartExtras() {
    const extrasList = document.querySelector('.extras .list')
    if (!extrasList) return

    // Get extras data
    const extrasData = JSON.parse(extrasList.getAttribute('data-addons-data') || '{}')
    const orderAddons: Array<{ id: string; count?: number }> = JSON.parse(
      localStorage.getItem('cart_order_addons') || '[]'
    )

    // Clear list first
    extrasList.innerHTML = ''

    // Prepare arrays for selected and unselected addons
    const selectedAddons: Array<{ _key: string; name: string; image: any; pricing: any }> = []
    const unselectedAddons: Array<{ _key: string; name: string; image: any; pricing: any }> = []

    // Create a combined list of all addons
    const allAddons: Array<{
      _key: string
      name: string
      image: any
      pricing: {
        type: string
        fixedPrice?: number
        threshold?: {
          basePrice: number
          maxUnits: number
          additionalPrice: number
          singular: string
        }
      }
    }> = []

    // Add transport option
    if (extrasData.transportOptions) {
      allAddons.push({
        _key: 'transport',
        name: t.transportAddonName,
        image: extrasData.transportOptions.image,
        pricing: extrasData.transportOptions.pricing,
      })
    }

    // Add regular addons from Sanity
    if (extrasData.addonsList && Array.isArray(extrasData.addonsList)) {
      allAddons.push(...extrasData.addonsList)
    }

    // Now sort addons into selected and unselected groups
    allAddons.forEach((addon) => {
      const isSelected = orderAddons.some((item) => item.id === addon._key)
      if (isSelected) {
        selectedAddons.push(addon)
      } else {
        unselectedAddons.push(addon)
      }
    })

    // First render ALL selected addons
    for (const addon of selectedAddons) {
      const extraElement = await renderExtra(addon, true)
      if (extraElement) {
        extrasList.appendChild(extraElement)
      }
    }

    // Calculate how many unselected addons to show initially
    // Show up to 6 total items in the initial view
    const maxInitialAddons = 6
    const remainingSlots = Math.max(0, maxInitialAddons - selectedAddons.length)

    // Then show some unselected addons (limited number)
    const visibleUnselectedAddons = unselectedAddons.slice(0, remainingSlots)
    const hiddenAddons = unselectedAddons.slice(remainingSlots)

    // Render visible unselected addons
    for (const addon of visibleUnselectedAddons) {
      const extraElement = await renderExtra(addon, false)
      if (extraElement) {
        extrasList.appendChild(extraElement)
      }
    }

    // Combine all addons for the popup, with selected first
    const sortedAddons = [...selectedAddons, ...unselectedAddons]

    // Setup show more button
    const showMoreButton = document.querySelector('.show-more-extras')
    if (showMoreButton) {
      showMoreButton.setAttribute('data-hidden-addons', JSON.stringify(hiddenAddons))

      // Hide button if no more addons to show
      const showMoreWrapper = document.querySelector('.show-more-wrapper')
      if (showMoreWrapper && hiddenAddons.length === 0) {
        if (showMoreWrapper instanceof HTMLElement) {
          showMoreWrapper.style.display = 'none'
        }
      }

      // Setup click event
      showMoreButton.addEventListener('click', () => {
        openAddonsPopup(sortedAddons)
      })
    }

    // Update count display
    updateExtrasCount()
  }

  // State management functions
  function showState(state: 'loading' | 'empty' | 'error' | 'content' | 'submit-loading' | 'submit-error') {
    // Get all state elements
    const states = document.querySelectorAll('.cart-container .state')

    // Hide all states
    states.forEach((el) => {
      ;(el as HTMLElement).style.display = 'none'
    })

    // Show requested state
    const stateEl = document.querySelector(`.state-${state}`) as HTMLElement | null
    if (stateEl) {
      stateEl.style.display = 'flex'
    }

    // Scroll to top of the page smoothly
    window.scrollTo({
      top: 0,
      behavior: 'instant',
    })
  }

  // Check cart before fetching
  function checkCartBeforeFetching() {
    const cart = cartStore.get()
    const hasItems = cart.hotels.length > 0 || cart.activities.length > 0

    if (!hasItems) {
      // Show empty state immediately without fetching
      showState('empty')
      return false
    }

    // Has items, proceed with fetching
    return true
  }

  // Main function to load cart items
  async function loadCartItems(isRetry = false) {
    if (!isRetry) {
      // On first load, show loader and check cart
      showState('loading')

      // If cart is empty, don't proceed with fetching
      if (!checkCartBeforeFetching()) {
        return
      }
    }

    try {
      // Get cart data from store
      const cart = cartStore.get()

      // If all items are already cached and this is not a retry, use cached data
      if (cachedCartData.isComplete() && !isRetry) {
        // Render items from cache
        await renderCartItems(cachedCartData.hotels, cachedCartData.activities)
        // Load extras
        await loadCartExtras()
        // Show content state
        showState('content')
        // Update participant alerts after everything is loaded
        setTimeout(() => {
          updateParticipantAlerts()
          // Update transport cards with address if needed
          updateTransportCardWithAddress()

          // Dispatch cart-loaded event after everything is ready
          if (!isRetry) {
            document.dispatchEvent(new CustomEvent('cart-loaded'))
          }
        }, 100)
        return
      }

      // Fetch all hotels
      const hotelPromises = cart.hotels.map(async (item) => {
        try {
          const addonIds = item.addOns.map((addon) => addon.id)
          const hotelData = await fetchHotelData(item.id, addonIds)
          if (hotelData) {
            const matchedAddons = item.addOns
              .map((addon: AddonItem) => {
                const fullAddon = hotelData.addons?.addonsList?.find((a: any) => a._key === addon.id)
                return {
                  ...addon,
                  fullData: fullAddon || null,
                }
              })
              .filter((addon) => addon.fullData !== null)

            const enhancedHotelData = {
              ...hotelData,
              cartAddons: matchedAddons,
            }

            // Update cache
            cachedCartData.updateHotel(item.id, enhancedHotelData)

            return enhancedHotelData
          }
          return null
        } catch (error) {
          console.error(`Error fetching hotel ${item.id}:`, error)
          return null
        }
      })

      // Fetch all activities
      const activityPromises = cart.activities.map(async (item) => {
        try {
          const addonIds = item.addOns.map((addon) => addon.id)
          const activityData = await fetchActivityData(item.id, addonIds)
          if (activityData) {
            const matchedAddons = item.addOns
              .map((addon: AddonItem) => {
                const fullAddon = activityData.addons?.addonsList?.find((a: any) => a._key === addon.id)
                return {
                  ...addon,
                  fullData: fullAddon || null,
                }
              })
              .filter((addon) => addon.fullData !== null)

            const enhancedActivityData = {
              ...activityData,
              cartAddons: matchedAddons,
            }

            // Update cache
            cachedCartData.updateActivity(item.id, enhancedActivityData)

            return enhancedActivityData
          }
          return null
        } catch (error) {
          console.error(`Error fetching activity ${item.id}:`, error)
          return null
        }
      })

      // Wait for all fetches to complete
      const [hotels, activities] = await Promise.all([Promise.all(hotelPromises), Promise.all(activityPromises)])

      // Filter out null results
      const validHotels = hotels.filter(Boolean)
      const validActivities = activities.filter(Boolean)

      // Mark cache as loaded
      cachedCartData.isLoaded = true

      // If nothing was fetched successfully, show empty state
      if (validHotels.length === 0 && validActivities.length === 0) {
        showState('empty')
        return
      }

      // Render the cart items
      await renderCartItems(validHotels, validActivities)

      // Load extras
      await loadCartExtras()

      // Show content state
      showState('content')

      // Update participant alerts after everything is loaded
      setTimeout(() => {
        updateParticipantAlerts()
        // Update transport cards with address if needed
        updateTransportCardWithAddress()

        // Dispatch cart-loaded event after everything is ready
        if (!isRetry) {
          document.dispatchEvent(new CustomEvent('cart-loaded'))
        }
      }, 100)
    } catch (error) {
      console.error('Error loading cart items:', error)
      showState('error')
    }
  }

  // Listen for cart updates (both hotels and activities)
  document.addEventListener('cart-updated', async (event) => {
    type CartEventDetail = {
      itemId: string
      itemType: 'hotels' | 'activities'
      action: 'remove' | 'update'
    }

    type CartAddon = {
      id: string
      count?: number
    }

    type CartItem = {
      id: string
      addOns: CartAddon[]
    }

    const detail = (event as CustomEvent<CartEventDetail>).detail
    if (!detail || !detail.itemId || !detail.itemType || !detail.action) return

    const item = document.querySelector(`[data-item-id="${detail.itemId}"]`) as HTMLElement | null
    if (!item) return

    if (detail.action === 'remove') {
      const cartHeadingCount = document.querySelector('.state-content .header .cart-heading .count')! as HTMLSpanElement
      // Animate removal and then remove from DOM
      item.classList.add('removing')
      setTimeout(() => {
        item.remove()

        // Get current cart state after removal
        const cart = cartStore.get()
        const hasHotels = cart.hotels.length > 0
        const hasActivities = cart.activities.length > 0

        // Update cache to remove the item
        if (detail.itemType === 'hotels') {
          cachedCartData.updateHotel(detail.itemId, null)
        } else if (detail.itemType === 'activities') {
          cachedCartData.updateActivity(detail.itemId, null)
        }

        // Check if there are no more items of this type
        const section = document.querySelector(`.${detail.itemType}-section`)
        const otherType = detail.itemType === 'hotels' ? 'activities' : 'hotels'
        const otherSection = document.querySelector(`.${otherType}-section`)
        const updatedItemType = detail.itemType === 'hotels' ? 'hotel' : 'activity'

        // Update main cart count
        cartHeadingCount.textContent = `${cart.hotels.length + cart.activities.length}`

        if (section) {
          const remainingItems = section.querySelectorAll(`.${updatedItemType}-item`).length
          // Update count
          const countElement = section.querySelector('.count')
          if (countElement) {
            countElement.textContent = remainingItems.toString()
          }

          // If no more items of this type, render empty section alert
          if (remainingItems === 0) {
            const sectionList = section.querySelector('.list') as HTMLElement
            if (sectionList) {
              // Clear any existing content
              sectionList.innerHTML = ''

              // Render empty section alert for this section
              const sectionType = detail.itemType as 'hotels' | 'activities'
              renderEmptySectionAlert(sectionList, sectionType)
            }
          }
        }

        // Handle other section visibility and empty state
        if (otherSection) {
          const otherItemType = otherType === 'hotels' ? 'hotel' : 'activity'
          const hasOtherItems = otherSection.querySelectorAll(`.${otherItemType}-item`).length > 0

          if (!hasOtherItems) {
            const otherList = otherSection.querySelector('.list') as HTMLElement
            if (otherList && otherList.querySelector('.alert-item') === null) {
              // Only render if there's no alert already
              otherList.innerHTML = ''
              renderEmptySectionAlert(otherList, otherType as 'hotels' | 'activities')
            }
          }
        }

        // Check if cart is completely empty
        if (!hasHotels && !hasActivities) {
          // Show empty state and hide content state
          showState('empty')
        }
      }, 300)
    } else if (detail.action === 'update') {
      // Update addons list if it exists
      const addonList = item.querySelector('.addon-list')
      if (addonList) {
        const cart = cartStore.get()
        const cartItem = cart[detail.itemType].find((i: CartItem) => i.id === detail.itemId)
        addonList.innerHTML = ''

        if (cartItem && cartItem.addOns.length > 0) {
          const addonsNames = JSON.parse(item.getAttribute('data-addon-names') || '{}')
          cartItem.addOns.forEach((addon: CartAddon) => {
            const li = document.createElement('li')
            li.innerHTML = addon.count
              ? `${addonsNames.find((a: any) => a.id === addon.id)?.name}: <strong>${addon.count}</strong>`
              : addonsNames.find((a: any) => a.id === addon.id)?.name
            addonList.appendChild(li)
          })
        }

        // Update addons button state
        const addonsButton = item.querySelector('.addons')
        if (addonsButton) {
          const hasAddons = cartItem && cartItem.addOns.length > 0
          addonsButton.setAttribute('data-is-editing', hasAddons ? 'true' : 'false')
          const span = addonsButton.querySelector('.text')
          if (span) {
            span.innerHTML = hasAddons ? t.editAddons : `${t.addons} <strong>${t.optional}</strong>`
          }
        }
      }
    }
  })

  // Cached data store for hotels and activities
  const cachedCartData = {
    hotels: [] as ExtendedHotelData[],
    activities: [] as ExtendedActivityData[],
    isLoaded: false,

    // Method to clear cache
    clear() {
      this.hotels = []
      this.activities = []
      this.isLoaded = false
    },

    // Method to update a specific hotel
    updateHotel(hotelId: string, data: ExtendedHotelData | null) {
      if (!data) {
        this.hotels = this.hotels.filter((h) => h._id !== hotelId)
        return
      }

      const index = this.hotels.findIndex((h) => h._id === hotelId)
      if (index >= 0) {
        this.hotels[index] = data
      } else {
        this.hotels.push(data)
      }
    },

    // Method to update a specific activity
    updateActivity(activityId: string, data: ExtendedActivityData | null) {
      if (!data) {
        this.activities = this.activities.filter((a) => a._id !== activityId)
        return
      }

      const index = this.activities.findIndex((a) => a._id === activityId)
      if (index >= 0) {
        this.activities[index] = data
      } else {
        this.activities.push(data)
      }
    },

    // Method to check if all items in the cart are cached
    isComplete() {
      const cart = cartStore.get()

      // Check if all hotels in cart are in cache
      const allHotelsCached = cart.hotels.every((item) => this.hotels.some((h) => h._id === item.id))

      // Check if all activities in cart are in cache
      const allActivitiesCached = cart.activities.every((item) => this.activities.some((a) => a._id === item.id))

      return allHotelsCached && allActivitiesCached
    },
  }
</script>
