---
import { getLangFromPath, type Language } from '@/src/global/languages'
import metadataFetch from '@/src/utils/metadata.fetch'
import sanityFetch from '@/src/utils/sanity.fetch'
import PortableText, { PortableTextQuery, type PortableTextValue } from '@/src/components/ui/portable-text'
import ActivityTemplate from './ActivityTemplate.astro'
import HotelTemplate from './HotelTemplate.astro'
import ExtrasTemplate from './ExtrasTemplate.astro'
import GastronomyTemplate from './GastronomyTemplate.astro'
import EditGastronomyModal from './EditGastronomyModal.astro'
import Button from '@/src/components/ui/Button'
import AddonsPopup from '@/src/components/offer/AddonsPopup.astro'
import RemoveConfirmation from '@/src/components/ui/RemoveConfirmation.astro'
import DatePicker from '@/src/components/ui/DatePicker.astro'
import AlertTemplate from './AlertTemplate.astro'
import Image, { ImageDataQuery } from '@/src/components/ui/image'
import PopupWindow from '@/src/components/ui/PopupWindow/index.astro'
import CloseButton from '@/src/components/ui/PopupWindow/CloseButton.astro'
import AddressForm from '@/src/components/cart/form'
import ActivityAddressForm from '@/src/components/cart/form/ActivityAddressForm'
import SkeletonLoader from '@/src/components/cart/SkeletonLoader.astro'
import type { ExtraItem } from '@/src/global/types'
import QuoteCartLayout from '@/src/layouts/QuoteCartLayout.astro'
import AdditionalInfoBlock from '@/src/components/cart/AdditionalInfoBlock.astro'
import Loader from '@/src/components/ui/Loader.astro'

type Props = NonNullable<Awaited<ReturnType<typeof fetchData>>>

export async function fetchData(lang: Language) {
  const [page] = await Promise.all([
    sanityFetch<{
      name: string
      slug: string
      infoParagraph: PortableTextValue
      noResults: {
        heading: PortableTextValue
        paragraph: PortableTextValue
      }
      errorState: {
        heading: PortableTextValue
        paragraph: PortableTextValue
      }
      orderAddons: {
        transportOptions: ExtraItem & {
          pricing: {
            basePrice: number
            maxKilometers: number
            pricePerKm: number
            maxPeoplePerBus: number
          }
        }
        addonsList: Array<ExtraItem>
      }
    }>({
      query: `
        *[_type == "Cart_Page" && language == $language][0] {
          name,
          "slug": slug.current,
          ${PortableTextQuery('infoParagraph')}
          noResults {
            ${PortableTextQuery('heading')}
            ${PortableTextQuery('paragraph')}
          },
          errorState {
            ${PortableTextQuery('heading')}
            ${PortableTextQuery('paragraph')}
          },
          orderAddons {
            transportOptions {
              ${ImageDataQuery('image')}
              pricing {
                basePrice,
                maxKilometers,
                pricePerKm,
                maxPeoplePerBus,
              },
            },
            addonsList[] {
              _key,
              name,
              ${ImageDataQuery('image')}
              pricing {
                type,
                fixedPrice,
                threshold {
                  basePrice,
                  maxUnits,
                  additionalPrice,
                  singular,
                },
              },
            },
          },
        }
      `,
      params: { language: lang },
    }),
    // Hotels data no longer needed with dynamic gastronomy system
    // sanityFetch<
    //   Array<{
    //     gastronomy: {
    //       lunch: Array<{ level: string; style: string; pricePerPersonPerDay: number; hidePricing: boolean }>
    //       dinner: Array<{ level: string; style: string; pricePerPersonPerDay: number; hidePricing: boolean }>
    //       coffeeBreak: { availability: string; pricePerPersonPerDay: number }
    //       grill: { availability: string; pricePerPersonPerDay: number }
    //     }
    //   }>
    // >({
    //   query: `*[_type == "Hotels_Collection" && language == $lang] {
    //     gastronomy {
    //       lunch[] {
    //         level,
    //         style,
    //         pricePerPersonPerDay,
    //         hidePricing
    //       },
    //       dinner[] {
    //         level,
    //         style,
    //         pricePerPersonPerDay,
    //         hidePricing
    //       },
    //       coffeeBreak {
    //         availability,
    //         pricePerPersonPerDay
    //       },
    //       grill {
    //         availability,
    //         pricePerPersonPerDay
    //       }
    //     }
    //   }`,
    //   params: { lang },
    // }),
  ])

  if (!page) return null

  const metadata = await metadataFetch(page.slug)

  if (!metadata) return null

  // Process gastronomy pricing from hotels data
  // Note: This is no longer used with the new dynamic gastronomy system
  // const gastronomyPricing = processGastronomyPricing(hotels)

  return {
    metadata,
    page,
    // gastronomyPricing, // Removed as no longer needed
  }
}

const lang = (getLangFromPath(Astro.url.pathname) as Language) || 'pl'

const translations = {
  pl: {
    back: {
      content: 'Wróć do przeglądania integracji i hoteli',
      url: '/pl/',
    },
    cartHeading: 'Twój koszyk',
    activitiesHeading: 'Integracje',
    hotelsHeading: 'Hotele',
    extrasHeading: 'Dodaj coś ekstra',
    optional: '(opcjonalne)',
    howManyParticipants: 'Ile osób bierze udział?',
    participantPlaceholder: 'Dodaj wartość',
    whichDate: 'Kiedy planujecie pobyt i/lub event?',
    getQuote: {
      text: 'Otrzymaj wstępną wycenę',
      additionalInfo: 'W następnym kroku poznasz wycenę. Nie oznacza to rezerwacji hotelu ani integracji',
    },
    addGastronomy: 'Dodaj usługę <strong>gastronomiczną</strong>',
    hotels: 'Hotele',
    hotelsPrefix: '/pl/hotele/',
    activities: 'Integracje',
    activitiesPrefix: '/pl/integracje/',
    people: 'osób',
    person: 'osoba',
    to: 'do',
    from: 'od',
    additionalPerson: 'Każda dodatkowa osoba',
    additionalKilometer: 'Każdy dodatkowy kilometr',
    currency: 'zł',
    perNight: 'zł/noc za osobę',
    max: 'Maks.',
    addons: 'Dobierz dodatki',
    editAddons: 'Edytuj dodatki',
    transportAddonName: 'Transport',
    selectAddon: 'Wybierz',
    showMoreExtras: 'Zobacz wszystkie dodatki',
    selectExtrasHeading: 'Wybierz dodatki',
    confirmAddons: 'Zatwierdź wybór',
    allAddons: 'Wszystkie <strong>dodatki</strong>',
    priceNotAvailable: 'Cena dostępna w wycenie',
    missingParticipants: 'Podaj liczbę uczestników przed wysłaniem wyceny',
    missingDates: 'Musisz wybrać co najmniej jeden termin',
    emptySection: {
      hotels: {
        heading: 'Nie wybrałeś jeszcze <strong>żadnego hotelu</strong>',
        paragraph:
          'Jeśli potrzebujerz dobrać <strong>hotel do wybranych integracji</strong>, wybierz hotel z naszej oferty klikając w przycisk poniżej.',
        button: 'Przeglądaj hotele',
      },
      activities: {
        heading: 'Nie wybrałeś jeszcze <strong>żadnych integracji</strong>',
        paragraph:
          'Jeśli potrzebujerz dobrać <strong>integracje do wybranych hoteli</strong>, wybierz integracje z naszej oferty klikając w przycisk poniżej.',
        button: 'Przeglądaj integracje',
      },
      gastronomy: {
        heading: 'Nie dodałeś jeszcze <strong>żadnych usług gastronomicznych</strong>',
        paragraph:
          'Dodaj <strong>catering, obiady, kolacje</strong> lub inne usługi gastronomiczne do swojej wyceny, aby zapewnić kompleksową obsługę eventu.',
        button: 'Dodaj usługę gastronomiczną',
      },
    },
    addressForm: {
      transportName: 'Transport',
      formHeading: 'Skąd was odebrać?',
      title: 'Edytuj <strong>adres</strong>',
      street: 'Ulica i numer*',
      streetPlaceholder: 'np. Kwiatowa 56/23b',
      streetRequired: 'Ulica i numer są wymagane',
      postal: 'Kod pocztowy*',
      postalPlaceholder: '__ - ___',
      postalRequired: 'Kod pocztowy jest wymagany',
      postalPattern: 'Wprowadź kod w formacie: XX-XXX',
      city: 'Miasto*',
      cityRequired: 'Miasto jest wymagane',
      peoplePerBus: 'Ile osób w autobusie?*',
      peoplePerBusPlaceholder: 'Wprowadź liczbę',
      peoplePerBusRequired: 'Liczba osób w autobusie jest wymagana',
      peoplePerBusMax: 'Nie można przekroczyć liczby uczestników',
      submit: 'Zapisz adres',
      editButton: 'Edytuj adres',
      pickFromMap: 'Wybierz z mapy',
      searchLocation: 'Szukaj lokalizacji',
      confirm: 'Zatwierdź',
      cancel: 'Anuluj',
      mapTooltip: 'Otwórz mapę, aby wybrać lokalizację',
      busCapacityInfo:
        'Jeden autobus może przewieźć maksymalnie **{maxPeoplePerBus} osób**. Przekroczenie tej liczby wymaga dodatkowego autobusu, co zwiększy koszt transportu proporcjonalnie.',
    },
    missingParticipantsForTransport: 'Najpierw podaj liczbę uczestników, aby dodać transport',
    transportRemoval: {
      title: 'Czy na pewno chcesz usunąć <strong>Transport</strong> z wyceny?',
      message: 'Usunięcie transportu spowoduje również usunięcie wprowadzonego adresu.',
      confirm: 'Tak, usuń',
      cancel: 'Anuluj',
      successToast: 'Transport został usunięty',
    },
    transportAutoAdjustment: {
      notification: 'Liczba osób w autobusie została automatycznie dostosowana do {newCount} (liczba uczestników)',
    },
    participantExceedsMaxAlert: {
      heading: 'Ten hotel jest maksymalnie dla <strong>{maxPeople}</strong> osób',
      paragraph: 'Możesz kontynuować wycenę albo zmienić hotel, który pomieści więcej osób.',
      cta: {
        text: 'Przeglądaj hotele',
        href: '/pl/hotele/',
      },
    },
    activityParticipantBelowMinAlert: {
      heading: 'Ta integracja wymaga minimum <strong>{minPeople}</strong> osób',
      paragraph: 'Możesz kontynuować wycenę albo dostosować liczbę uczestników.',
      cta: {
        text: 'Przeglądaj integracje',
        href: '/pl/integracje/',
      },
    },
    activityParticipantExceedsMaxAlert: {
      heading: 'Ta integracja jest maksymalnie dla <strong>{maxPeople}</strong> osób',
      paragraph: 'Możesz kontynuować wycenę albo zmienić integrację, która pomieści więcej osób.',
      cta: {
        text: 'Przeglądaj integracje',
        href: '/pl/integracje/',
      },
    },
    states: {
      error: {
        retryButton: 'Spróbuj ponownie',
      },
      submitError: {
        heading: 'Nie udało nam się stworzyć <strong>twojej wyceny</strong>',
        paragraph: 'Wystąpił błąd podczas tworzenia wyceny. Spróbuj ponownie ponownie lub skontaktuj się z nami.',
        returnButton: 'Wróć do koszyka',
      },
      empty: {
        ctaHotels: 'Przeglądaj hotele',
        ctaActivities: 'Przeglądaj integracje',
      },
    },
    activityAddressForm: {
      title: 'Wybierz <strong>lokalizację integracji</strong>',
      formHeading: 'Gdzie ma odbyć się integracja?',
      street: 'Ulica i numer*',
      streetPlaceholder: 'np. Kwiatowa 56/23b',
      streetRequired: 'Ulica i numer są wymagane',
      postal: 'Kod pocztowy*',
      postalPlaceholder: '__ - ___',
      postalRequired: 'Kod pocztowy jest wymagany',
      postalPattern: 'Wprowadź kod w formacie: XX-XXX',
      city: 'Miasto*',
      cityRequired: 'Miasto jest wymagane',
      submit: 'Zatwierdź lokalizację',
      pickFromMap: 'Wybierz z mapy',
      searchLocation: 'Szukaj lokalizacji',
      confirm: 'Zatwierdź',
      cancel: 'Anuluj',
      mapTooltip: 'Otwórz mapę, aby wybrać lokalizację',
    },
    gastronomy: {
      title: 'Gastronomia',
      addService: 'Dodaj usługę gastronomiczną',
      addServicePopupTitle: 'Dodaj usługę gastronomiczną',
      serviceType: 'Typ usługi:',
      serviceTypeSelect: 'Wybierz typ...',
      serviceCount: 'Liczba serwisów:',
      level: 'Poziom:',
      servingStyle: 'Sposób serwowania:',
      served: 'Na talerzu',
      buffet: 'Bufet',
      types: {
        lunch: 'Lunch',
        supper: 'Kolacja',
        'coffee-break': 'Coffee Break',
        grill: 'Grill',
        'open-bar': 'Open Bar',
      },
      levels: {
        economy: 'Economy',
        standard: 'Standard',
        exclusive: 'Exclusive',
      },
      styles: {
        served: 'Na talerzu',
        buffet: 'Bufet',
      },
      emptyMessage: 'Nie dodano jeszcze żadnych usług gastronomicznych',
      edit: 'Edytuj',
      editOptions: 'Edytuj opcje',
      cancel: 'Anuluj',
      add: 'Dodaj usługę',
      save: 'Zapisz',
      alerts: {
        selectType: 'Wybierz typ usługi',
        selectLevelAndStyle: 'Wybierz poziom i sposób serwowania',
        selectLevel: 'Wybierz poziom',
      },
      success: {
        serviceAdded: 'Usługa gastronomiczna została dodana pomyślnie',
        serviceRemoved: 'Usługa gastronomiczna została usunięta',
      },
    },
  },
  en: {
    back: {
      content: 'Back to activities and hotels',
      url: '/en/',
    },
    cartHeading: 'Your cart',
    activitiesHeading: 'Activities',
    hotelsHeading: 'Hotels',
    extrasHeading: 'Add something extra',
    optional: '(optional)',
    howManyParticipants: 'How many participants?',
    participantPlaceholder: 'Add value',
    whichDate: 'Which date?',
    getQuote: {
      text: 'Get a quote',
      additionalInfo:
        'In the next step, you will receive a quote. This does not mean a hotel reservation or integration reservation',
    },
    addGastronomy: 'Add <strong>gastronomy</strong> service',
    hotels: 'Hotels',
    hotelsPrefix: '/en/hotels/',
    activities: 'Activities',
    activitiesPrefix: '/en/activities/',
    people: 'people',
    person: 'person',
    from: 'from',
    to: 'to',
    currency: 'PLN',
    additionalPerson: 'Each additional person',
    additionalKilometer: 'Each additional kilometer',
    perNight: 'PLN/night per person',
    missingParticipants: 'Enter the number of participants before sending the quote',
    missingDates: 'You must select at least one date',
    max: 'Max.',
    addons: 'Add add-ons',
    editAddons: 'Edit add-ons',
    transportAddonName: 'Transport',
    selectAddon: 'Select',
    showMoreExtras: 'Show all extras',
    selectExtrasHeading: 'Select extras',
    confirmAddons: 'Confirm selection',
    allAddons: 'All <strong>extras</strong>',
    emptySection: {
      hotels: {
        heading: "You don't have any hotels yet",
        paragraph: 'Choose a hotel that best suits your trip needs.',
        button: 'Browse hotels',
      },
      activities: {
        heading: "You don't have any activities yet",
        paragraph: 'Choose activities that will ensure a great time during your trip.',
        button: 'Browse activities',
      },
      gastronomy: {
        heading: 'Nie dodałeś jeszcze <strong>żadnych usług gastronomicznych</strong>',
        paragraph:
          'Dodaj <strong>catering, obiady, kolacje</strong> lub inne usługi gastronomiczne do swojej wyceny, aby zapewnić kompleksową obsługę eventu.',
        button: 'Dodaj usługę gastronomiczną',
      },
    },
    addressForm: {
      transportName: 'Transport',
      formHeading: 'Where do you want to pick us up?',
      title: 'Edit <strong>address</strong>',
      street: 'Street and number*',
      streetPlaceholder: 'e.g. Flower 56/23b',
      streetRequired: 'Street and number are required',
      postal: 'Postal code*',
      postalPlaceholder: '__ - ___',
      postalRequired: 'Postal code is required',
      postalPattern: 'Enter code in the format: XX-XXX',
      city: 'City*',
      cityRequired: 'City is required',
      peoplePerBus: 'How many people per bus?*',
      peoplePerBusPlaceholder: 'Enter number',
      peoplePerBusRequired: 'Number of people per bus is required',
      peoplePerBusMax: 'Cannot exceed number of participants',
      submit: 'Save address',
      editButton: 'Edit address',
      pickFromMap: 'Pick from map',
      searchLocation: 'Search location',
      confirm: 'Confirm',
      cancel: 'Cancel',
      mapTooltip: 'Open map to select location',
      busCapacityInfo:
        'One bus can transport a maximum of **{maxPeoplePerBus} people**. Exceeding this number requires an additional bus, which will increase transport costs proportionally.',
    },
    missingParticipantsForTransport: 'First enter the number of participants to add transport',
    transportRemoval: {
      title: 'Are you sure you want to remove <strong>Transport</strong> from the quote?',
      message: 'Removing transport will also remove the address you entered.',
      confirm: 'Yes, remove',
      cancel: 'Cancel',
      successToast: 'Transport has been removed',
    },
    transportAutoAdjustment: {
      notification:
        'The number of people in the bus has been automatically adjusted to {newCount} (number of participants)',
    },
    participantExceedsMaxAlert: {
      heading: 'This hotel is maxed out for <strong>{maxPeople}</strong> people',
      paragraph: 'You can continue with the quote or change the hotel to one that can accommodate more people.',
      cta: {
        text: 'Browse hotels',
        href: '/en/hotels/',
      },
    },
    activityParticipantBelowMinAlert: {
      heading: 'This activity requires at least <strong>{minPeople}</strong> people',
      paragraph: 'You can continue with the quote or adjust the number of participants.',
      cta: {
        text: 'Browse activities',
        href: '/en/activities/',
      },
    },
    activityParticipantExceedsMaxAlert: {
      heading: 'This activity is maxed out for <strong>{maxPeople}</strong> people',
      paragraph: 'You can continue with the quote or change the activity to one that can accommodate more people.',
      cta: {
        text: 'Browse activities',
        href: '/en/activities/',
      },
    },
    states: {
      error: {
        retryButton: 'Try Again',
      },
      submitError: {
        heading: 'Failed to create quote',
        paragraph: 'There was an error while creating your quote. Please try again or contact us.',
        returnButton: 'Return to Cart',
      },
      empty: {
        ctaHotels: 'Browse hotels',
        ctaActivities: 'Browse activities',
      },
    },
    activityAddressForm: {
      title: 'Select <strong>activity location</strong>',
      formHeading: 'Where should the activity take place?',
      street: 'Street and number*',
      streetPlaceholder: 'e.g. Flower 56/23b',
      streetRequired: 'Street and number are required',
      postal: 'Postal code*',
      postalPlaceholder: '__ - ___',
      postalRequired: 'Postal code is required',
      postalPattern: 'Enter code in the format: XX-XXX',
      city: 'City*',
      cityRequired: 'City is required',
      submit: 'Confirm location',
      pickFromMap: 'Pick from map',
      searchLocation: 'Search location',
      confirm: 'Confirm',
      cancel: 'Cancel',
      mapTooltip: 'Open map to select location',
    },
    priceNotAvailable: 'Price available in quote',
    gastronomy: {
      title: 'Gastronomy',
      addService: 'Add gastronomy service',
      addServicePopupTitle: 'Add gastronomy service',
      serviceType: 'Service type:',
      serviceTypeSelect: 'Select type...',
      serviceCount: 'Number of services:',
      level: 'Level:',
      servingStyle: 'Serving style:',
      served: 'Served',
      buffet: 'Buffet',
      types: {
        lunch: 'Lunch',
        supper: 'Dinner',
        'coffee-break': 'Coffee Break',
        grill: 'Grill',
        'open-bar': 'Open Bar',
      },
      levels: {
        economy: 'Economy',
        standard: 'Standard',
        exclusive: 'Exclusive',
      },
      styles: {
        served: 'Served',
        buffet: 'Buffet',
      },
      emptyMessage: 'No gastronomy services added yet',
      edit: 'Edit',
      editOptions: 'Edit options',
      cancel: 'Cancel',
      add: 'Add service',
      save: 'Save',
      alerts: {
        selectType: 'Please select service type',
        selectLevelAndStyle: 'Please select level and serving style',
        selectLevel: 'Please select level',
      },
      success: {
        serviceAdded: 'Gastronomy service added successfully',
        serviceRemoved: 'Gastronomy service removed successfully',
      },
    },
  },
} as const

const t = translations[lang]

const { metadata, page } = Astro.props
---

<QuoteCartLayout
  backLink={{
    text: t.back.content,
    url: t.back.url,
  }}
  metadata={metadata}
  data-translations={JSON.stringify(translations[lang])}
  data-lang={lang}
  class="Cart"
>
  <div class="cart-container">
    <div class="state state-loading">
      <SkeletonLoader />
    </div>

    <div class="state state-empty" style="display: none;">
      <PortableText value={page.noResults.heading} heading="h1" />
      <PortableText value={page.noResults.paragraph} class="paragraph" />
      <div class="cta-buttons">
        <Button theme="primary" shade="light" href={t.hotelsPrefix}>{t.states.empty.ctaHotels}</Button>
        <Button theme="primary" href={t.activitiesPrefix}>{t.states.empty.ctaActivities}</Button>
      </div>
    </div>

    <div class="state state-error" style="display: none;">
      <PortableText value={page.errorState.heading} heading="h1" />
      <PortableText value={page.errorState.paragraph} class="paragraph" />
      <Button id="retry-load-cart">{t.states.error.retryButton}</Button>
    </div>

    <div class="state state-submit-loading" style="display: none;">
      <Loader />
    </div>

    <div class="state state-submit-error" style="display: none;">
      <h1><Fragment set:html={t.states.submitError?.heading} /></h1>
      <p class="paragraph">
        <Fragment set:html={t.states.submitError?.paragraph} />
      </p>
      <Button id="return-to-cart">{t.states.submitError?.returnButton}</Button>
    </div>

    <div class="state state-content items-wrapper" style="display: none;">
      <header class="header">
        <AdditionalInfoBlock additionalInfo={page.infoParagraph} />
        <h1 class="cart-heading">
          <span class="text">{t.cartHeading}</span>
          <span class="count">0</span>
        </h1>
        <div class="inputs">
          <div class="input-field participants">
            <label for="participantCount">
              <span class="label">{t.howManyParticipants}</span>
            </label>
            <div class="input-box">
              <div class="gradient"></div>
              <input
                type="number"
                id="participantCount"
                class="participant-input"
                min="1"
                step="1"
                placeholder={t.participantPlaceholder}
              />
            </div>
          </div>
          <DatePicker lang={lang} />
        </div>

        <!-- Gastronomy Section -->
        <div class="gastronomy-section">
          <h2 class="cart-heading cart-heading-s">
            <span class="title">{t.gastronomy.title} <strong>{t.optional}</strong></span>
            <span class="count" id="gastronomy-count">0</span>
          </h2>
          <div class="gastronomy-list">
            <!-- Dynamic list of gastronomy items will be populated by JavaScript -->
          </div>

          <!-- Empty state alert container (shown when no items) -->
          <div class="gastronomy-empty-alert">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none">
              <path
                fill="#F67258"
                fill-rule="evenodd"
                d="M14.67 8A6.667 6.667 0 1 1 1.335 8a6.667 6.667 0 0 1 13.333 0Zm-6.667 3.834a.5.5 0 0 0 .5-.5v-4a.5.5 0 1 0-1 0v4a.5.5 0 0 0 .5.5Zm0-7.167a.667.667 0 1 1 0 1.333.667.667 0 0 1 0-1.333Z"
                clip-rule="evenodd"></path>
            </svg>
            <div class="wrapper">
              <div class="alert-heading">
                <Fragment set:html={t.emptySection.gastronomy.heading} />
              </div>
              <div class="alert-paragraph">
                <Fragment set:html={t.emptySection.gastronomy.paragraph} />
              </div>
              <Button theme="secondary" className="add-gastronomy-button" id="add-gastronomy-btn-empty">
                {t.emptySection.gastronomy.button}
              </Button>
            </div>
          </div>

          <!-- Normal add button (shown when there are items) -->
          <Button
            theme="secondary"
            className="add-gastronomy-button add-gastronomy-normal hidden"
            id="add-gastronomy-btn"
          >
            {t.gastronomy.addService}
          </Button>
        </div>
      </header>
      <div class="hotels-section">
        <h2 class="cart-heading cart-heading-s">
          <span class="title">{t.hotelsHeading}</span>
          <span class="count">0</span>
        </h2>
        <ul class="list"></ul>
      </div>
      <div class="activities-section">
        <h2 class="cart-heading cart-heading-s">
          <span class="title">{t.activitiesHeading}</span>
          <span class="count">0</span>
        </h2>
        <ul class="list"></ul>
      </div>
      <div class="extras">
        <h2 class="cart-heading cart-heading-s">
          <span class="title">{t.extrasHeading} <strong>{t.optional}</strong></span>
          <span class="count">0</span>
        </h2>
        <ul class="list" data-addons-data={JSON.stringify(page.orderAddons)}></ul>
        <div class="show-more-wrapper">
          <Button className="show-more-extras" theme="secondary">
            {t.showMoreExtras}{' '}
            <strong>({page.orderAddons.addonsList.length + 1})</strong>
          </Button>
        </div>
      </div>
      <div class="actions">
        <Button id="get-quote-button">{t.getQuote.text}</Button>
        <p class="additional-info">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" fill="none"
            ><path
              fill="#F67258"
              fill-rule="evenodd"
              d="M6.398 2.382a3.817 3.817 0 0 1-.33.266 1.809 1.809 0 0 1-.657.272c-.103.02-.209.029-.422.046-.534.042-.801.063-1.024.142-.515.182-.92.588-1.103 1.103-.079.223-.1.49-.143 1.024-.017.213-.025.32-.045.422a1.809 1.809 0 0 1-.272.656 3.818 3.818 0 0 1-.266.33c-.348.409-.521.613-.623.826a1.809 1.809 0 0 0 0 1.56c.102.213.275.417.623.825.138.162.208.243.266.33.133.199.225.422.272.657.02.102.028.208.045.421.043.534.064.801.143 1.024.182.516.588.921 1.103 1.103.223.079.49.1 1.024.143.213.017.32.025.422.046.234.046.458.138.656.272.087.058.168.127.33.265.408.348.612.522.826.624a1.809 1.809 0 0 0 1.56 0c.213-.102.417-.276.825-.624a3.81 3.81 0 0 1 .33-.265 1.81 1.81 0 0 1 .656-.272c.103-.02.21-.03.422-.046.534-.043.801-.064 1.024-.143.516-.182.921-.587 1.103-1.103.079-.223.1-.49.143-1.024.017-.213.025-.319.046-.421.046-.235.138-.458.271-.657.059-.087.128-.168.266-.33.348-.408.521-.612.623-.825a1.809 1.809 0 0 0 0-1.56c-.102-.213-.275-.417-.623-.825a3.83 3.83 0 0 1-.266-.33 1.808 1.808 0 0 1-.271-.657c-.02-.103-.03-.209-.046-.422-.043-.534-.064-.801-.143-1.024a1.809 1.809 0 0 0-1.103-1.103c-.223-.079-.49-.1-1.024-.142a3.817 3.817 0 0 1-.421-.046 1.808 1.808 0 0 1-.657-.272 3.817 3.817 0 0 1-.33-.266c-.408-.347-.612-.521-.825-.623a1.809 1.809 0 0 0-1.56 0c-.214.102-.418.276-.825.623Zm4.52 4.442a.543.543 0 0 0-.767-.767L6.917 9.29 5.854 8.227a.543.543 0 1 0-.767.767l1.447 1.447a.543.543 0 0 0 .767 0l3.617-3.617Z"
              clip-rule="evenodd"></path></svg
          ><span>{t.getQuote.additionalInfo}</span>
        </p>
      </div>
    </div>
  </div>
</QuoteCartLayout>
<HotelTemplate />
<ActivityTemplate />
<AlertTemplate />
<ExtrasTemplate />
<GastronomyTemplate />
<EditGastronomyModal />

<PopupWindow>
  <Button slot="open" className="hidden-trigger" id="gastronomy-popup-trigger">Open</Button>
  <div slot="content" class="popup-content gastronomy-popup">
    <h2><Fragment set:html={t.addGastronomy} /></h2>
    <CloseButton />

    <form class="gastronomy-form">
      <div class="gastronomy-form-wrapper">
        <div class="form-field">
          <div class="label-with-error">
            <label>{t.gastronomy.serviceType}</label>
            <div class="form-error" id="service-type-error" style="display: none;" role="alert" aria-live="assertive">
            </div>
          </div>
          <div class="service-type-grid">
            <label class="service-type-option">
              <input type="radio" name="service-type" value="lunch" />
              <span class="option-content">
                <span class="option-title">{t.gastronomy.types.lunch}</span>
              </span>
            </label>
            <label class="service-type-option">
              <input type="radio" name="service-type" value="supper" />
              <span class="option-content">
                <span class="option-title">{t.gastronomy.types.supper}</span>
              </span>
            </label>
            <label class="service-type-option">
              <input type="radio" name="service-type" value="coffee-break" />
              <span class="option-content">
                <span class="option-title">{t.gastronomy.types['coffee-break']}</span>
              </span>
            </label>
            <label class="service-type-option">
              <input type="radio" name="service-type" value="grill" />
              <span class="option-content">
                <span class="option-title">{t.gastronomy.types.grill}</span>
              </span>
            </label>
            <label class="service-type-option">
              <input type="radio" name="service-type" value="open-bar" />
              <span class="option-content">
                <span class="option-title">{t.gastronomy.types['open-bar']}</span>
              </span>
            </label>
          </div>
        </div>

        <div class="form-field">
          <label for="service-count">{t.gastronomy.serviceCount}</label>
          <div class="quantity-control">
            <input type="number" id="service-count" min="1" value="10" class="quantity-input" />
            <button type="button" class="quantity-decrease">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none">
                <path stroke="#F67258" stroke-linecap="round" d="M16 10H4"></path>
              </svg>
            </button>
            <button type="button" class="quantity-increase">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none">
                <path stroke="#F67258" stroke-linecap="round" d="M10 5v10m5-5H5"></path>
              </svg>
            </button>
          </div>
        </div>

        <!-- Conditional options for lunch/supper -->
        <div class="meal-options" style="display: none;">
          <div class="label-with-error">
            <h3 class="meal-options-title">Szczegóły posiłku</h3>
            <div
              class="form-error"
              id="meal-options-error-inline"
              style="display: none;"
              role="alert"
              aria-live="assertive"
            >
            </div>
          </div>

          <div class="form-field">
            <label>{t.gastronomy.level}</label>
            <div class="radio-group">
              <label>
                <input type="radio" name="meal-level" value="economy" />
                <span>{t.gastronomy.levels.economy}</span>
              </label>
              <label>
                <input type="radio" name="meal-level" value="standard" />
                <span>{t.gastronomy.levels.standard}</span>
              </label>
              <label>
                <input type="radio" name="meal-level" value="exclusive" />
                <span>{t.gastronomy.levels.exclusive}</span>
              </label>
            </div>
          </div>
          <div class="form-field">
            <label>{t.gastronomy.servingStyle}</label>
            <div class="radio-group">
              <label>
                <input type="radio" name="meal-style" value="served" />
                <span>{t.gastronomy.styles.served}</span>
              </label>
              <label>
                <input type="radio" name="meal-style" value="buffet" />
                <span>{t.gastronomy.styles.buffet}</span>
              </label>
            </div>
          </div>
        </div>

        <div class="form-error" id="meal-options-error" style="display: none;" role="alert" aria-live="assertive"></div>
      </div>
      <div class="form-actions">
        <Button type="button" theme="primary" shade="light" data-popup-close>
          {t.gastronomy.cancel}
        </Button>
        <Button type="submit" theme="primary" shade="dark" className="submit-gastronomy">
          {t.gastronomy.add}
        </Button>
      </div>
    </form>
  </div>
</PopupWindow>

<AddonsPopup type="hotels" addons={{ hasAddons: true, addonsList: [] }} />
<RemoveConfirmation itemId="" itemType="hotels" hasAddons={false} lang={lang} itemName="" />
<PopupWindow>
  <Button slot="open" data-popup-id="extras-popup" className="hidden-trigger" id="extras-popup-trigger">Open</Button>
  <div slot="content" class="popup-content" data-popup-id="extras-popup-container">
    <div class="extras-container">
      <h2><Fragment set:html={t.allAddons} /></h2>
      <CloseButton />

      <div class="extras-list-wrapper">
        <ul class="extras-list"></ul>
      </div>
    </div>
  </div>
</PopupWindow>

<PopupWindow>
  <Button slot="open" className="hidden-trigger" id="transport-address-trigger">Open</Button>
  <div slot="content" class="popup-content address-popup">
    <h2><Fragment set:html={t.addressForm.title} /></h2>
    <CloseButton />
    <div class="address-form-container">
      <AdditionalInfoBlock
        text={t.addressForm.busCapacityInfo
          .replace('{maxPeoplePerBus}', page.orderAddons.transportOptions.pricing.maxPeoplePerBus.toString())
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}
      />

      <div class="transport-box">
        <Image {...page.orderAddons.transportOptions.image} sizes="100vw" />
        <h3>{t.addressForm.transportName}</h3>
        <div class="price-info">
          <p class="price">
            {
              page.orderAddons.transportOptions.pricing.maxKilometers ? (
                <>
                  <strong>
                    {t.from} {page.orderAddons.transportOptions.pricing.basePrice} {t.currency}
                  </strong>
                  <span>
                    / {t.to} {page.orderAddons.transportOptions.pricing.maxKilometers} km
                  </span>
                </>
              ) : (
                <strong>
                  {page.orderAddons.transportOptions.pricing.basePrice} {t.currency}
                </strong>
              )
            }
          </p>
          {
            page.orderAddons.transportOptions.pricing.maxKilometers && (
              <p class="price-details">
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" fill="none">
                  <path stroke="#F67258" stroke-linecap="round" d="M9 6.963H6m0 0H3m3 0v-3m0 3v3" />
                </svg>
                <span>{t.additionalKilometer}</span>
                <strong>
                  {page.orderAddons.transportOptions.pricing.pricePerKm} {t.currency}
                </strong>
              </p>
            )
          }
        </div>
      </div>

      <div class="address-form-wrapper">
        <p class="address-form-heading">{t.addressForm.formHeading}</p>
        <AddressForm client:idle translations={t.addressForm} />
      </div>
    </div>
  </div>
</PopupWindow>

<PopupWindow>
  <Button slot="open" className="hidden-trigger" id="transport-remove-trigger">Open</Button>
  <div slot="content" class="popup-content removal-confirmation">
    <CloseButton />
    <p class="title"><Fragment set:html={t.transportRemoval.title} /></p>
    <p class="message">{t.transportRemoval.message}</p>
    <div class="confirmation-actions">
      <Button theme="primary" shade="light" className="cancel-transport-remove">{t.transportRemoval.cancel}</Button>
      <Button theme="primary" shade="dark" className="confirm-transport-remove">{t.transportRemoval.confirm}</Button>
    </div>
  </div>
</PopupWindow>

<PopupWindow>
  <Button slot="open" className="hidden-trigger" id="activity-address-trigger">Open</Button>
  <div slot="content" class="popup-content activity-address-popup">
    <h2><Fragment set:html={t.activityAddressForm.title} /></h2>
    <CloseButton />

    <div class="activity-address-form-wrapper">
      <p class="activity-form-heading">{t.activityAddressForm.formHeading}</p>
      <ActivityAddressForm client:idle translations={t.activityAddressForm} />
    </div>
  </div>
</PopupWindow>

<style lang="scss">
  // Skeleton loader animation and base styles

  .Cart {
    padding: clamp(1rem, calc(3vw / 0.48), 4rem) 0 clamp(2rem, calc(4vw / 0.48), 4rem);
    scroll-behavior: unset;

    .cart-container {
      min-height: 30rem;
      padding: clamp(1rem, calc(2.75vw / 0.48), 2.75rem) 2.75rem;
      isolation: isolate;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;

      // State styles
      .state {
        width: 100%;
      }

      .state-loading {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 20rem;

        .loading-message {
          margin-top: 1rem;
          color: var(--primary-400);
          font-size: var(--typography-body-m, 0.875rem);
        }
      }

      .state-submit-loading {
        :global(> div) {
          background-color: transparent;
          backdrop-filter: blur(0px);
        }
      }

      .state-empty,
      .state-error,
      .state-submit-error {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        justify-content: center;
        padding: 2rem 0;

        h1,
        h2 {
          margin-bottom: 1rem;
          color: var(--primary-800);
        }

        p {
          max-width: 30rem;
          margin: 0 auto;

          :global(strong) {
            color: var(--primary-800);
            font-weight: 700;
          }
        }

        .cta-buttons {
          display: flex;
          justify-content: center;
          gap: 1rem;
          margin-top: 3rem;

          @media (max-width: 28.6875rem) {
            flex-direction: column;
            max-width: 100%;
            width: 100%;

            :global(a) {
              width: 100%;
              max-width: 100%;
              :global(span) {
                margin: 0 auto;
                padding-right: 1.75rem;
              }
            }
          }
        }

        @media (max-width: 28.6875rem) {
          text-align: start;
        }
      }
      .state-error,
      .state-submit-error {
        :global(button) {
          max-width: 20rem;
          width: 100%;
          margin: 3rem auto 0;

          :global(span) {
            margin: 0 auto;
            padding-right: 1.75rem;
          }

          @media (max-width: 28.6875rem) {
            max-width: 100%;
          }
        }
      }

      .items-wrapper {
        display: flex;
        flex-direction: column;
        gap: clamp(2rem, calc(2vw / 0.48), 2.25rem);
        .header {
          .inputs {
            margin-top: clamp(1rem, calc(1vw / 0.48), 1.5rem);
            display: flex;
            gap: 1rem;
            width: 100%;

            .input-field {
              flex: 1;
              display: flex;
              flex-direction: column;
              gap: 0.125rem;

              &.participants {
                max-width: 7.625rem;
              }

              .label {
                font-size: var(--typography-body-s, 0.75rem);
                line-height: 1.6;
                letter-spacing: -0.01em;
                color: var(--primary-800, #45051c);
              }

              .input-box {
                position: relative;
                isolation: isolate;
                background-color: var(--neutral-100, #faf7f7);
                border-radius: 0.25rem;

                &::before,
                &::after {
                  position: absolute;
                  z-index: -3;
                  inset: 0;
                  content: '';
                  background-color: var(--neutral-500, #d2c1b0);
                  border-radius: 0.25rem;
                  transition: background-color 275ms;
                }

                &::after {
                  z-index: -1;
                  inset: 0.125rem;
                  background: linear-gradient(var(--neutral-100, #faf7f7), var(--neutral-100, #faf7f7)) padding-box;
                  border-radius: 0.125rem;
                }

                &:hover::before {
                  background-color: var(--primary-400, #74535e);
                }

                .gradient {
                  position: absolute;
                  z-index: -2;
                  inset: 0;
                  overflow: hidden;
                  border-radius: 0.25rem;

                  &::before {
                    position: absolute;
                    inset: -0.0625rem;
                    content: '';
                    background: conic-gradient(
                      from 135deg at 50% 50%,
                      #798ddc 0deg,
                      #e7c78f 90deg,
                      #fa7468 266.40000343322754deg,
                      #798ddc 360deg
                    );
                    opacity: 0;
                    transform: scaleX(0);
                    transition:
                      opacity 125ms,
                      transform 475ms var(--easing);
                  }
                }

                input {
                  width: 100%;
                  min-height: 2.5rem;
                  padding: 0.625rem;
                  color: var(--primary-800, #45051c);
                  font-size: var(--typography-body-m, 0.875rem);
                  line-height: 1.4;
                  border-radius: 0.25rem;
                  border: none;
                  background: transparent;

                  &:focus-visible {
                    outline: none;
                  }

                  &::-webkit-outer-spin-button,
                  &::-webkit-inner-spin-button {
                    -webkit-appearance: none;
                    margin: 0;
                  }

                  /* Firefox */
                  &[type='number'] {
                    -moz-appearance: textfield;
                  }
                  &::placeholder {
                    font-size: var(--typography-body-m, 0.875rem);
                    color: var(--primary-400, #74535e);
                  }
                }

                &:has(input:focus-visible) {
                  .gradient {
                    &::before {
                      opacity: 1;
                      transform: scaleX(1);
                    }
                  }
                }
              }
            }
          }
        }

        .cart-heading {
          font-variant-numeric: lining-nums proportional-nums;
          font-size: var(--typography-body-2xl, 1.5rem);
          line-height: 1.25;
          font-weight: 700;
          font-family: 'Neue Haas Unica', 'Neue Haas Unica Fallback', sans-serif;
          color: var(--primary-800, #45051c);
          display: flex;
          align-items: center;
          letter-spacing: -0.04em;
          gap: 0.5rem;
          text-transform: none;

          :global(strong) {
            color: var(--primary-400, #74535e);
          }

          .count {
            display: grid;
            place-items: center;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 50%;
            background: var(--neutral-300, #faf7f7);
            font-size: var(--typography-body-l, 1rem);
            line-height: 1.55;
            letter-spacing: -0.03em;
            margin-top: 2px;
            padding-bottom: 2px;
            padding-right: 1px;
          }

          &-s {
            font-size: var(--typography-body-xl, 1.125rem);
            letter-spacing: -0.03em;
            line-height: 1.55;

            .count {
              font-size: var(--typography-body-m, 0.875rem);
              line-height: 1.7;
              letter-spacing: -0.02em;
            }
          }
        }

        .hotels-section,
        .activities-section {
          .cart-heading {
            margin-bottom: 1rem;
          }
          .list {
            display: flex;
            flex-direction: column;
            gap: clamp(0.375rem, calc(0.5vw / 0.48), 0.5rem);
          }
        }

        .hotels-section {
          padding-bottom: 0.75rem;
          border-bottom: 2px solid var(--neutral-300, #ede6de);
        }

        .extras {
          .cart-heading {
            margin-bottom: 0.75rem;
          }
          .list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            align-items: start;
          }

          .show-more-wrapper {
            margin-top: clamp(0.5rem, calc(1vw / 0.48), 1rem);
            display: flex;
            justify-content: center;
            :global(> button) {
              :global(strong) {
                color: var(--primary-400, #74535e);
              }
            }

            :global(> button:hover),
            :global(> button:focus) {
              > :global(span) strong {
                color: var(--neutral-100) !important;
              }
            }
          }
        }

        .actions {
          display: flex;
          flex-direction: column;

          :global(button) {
            max-width: 100%;
            width: 100%;
            margin-bottom: clamp(0.375rem, calc(0.5vw / 0.48), 0.5rem);

            :global(span) {
              margin: 0 auto;
              padding-right: 1.75rem;
            }

            &[data-loading='true'] {
              position: relative;
              pointer-events: none;

              &::after {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 1.25rem;
                height: 1.25rem;
                margin-top: -0.625rem;
                margin-left: -0.625rem;
                border-radius: 50%;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-top-color: white;
                animation: spin 0.8s linear infinite;
              }

              :global(span) {
                opacity: 0;
              }
            }
          }

          @keyframes spin {
            to {
              transform: rotate(360deg);
            }
          }

          .additional-info {
            gap: 0.375rem;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            font-size: var(--typography-body-m, 0.875rem);
            line-height: 1.7;
            letter-spacing: -0.01em;

            :global(svg) {
              flex-shrink: 0;
              margin-top: 4px;
            }
          }
        }

        .gastronomy-section {
          margin-top: clamp(1.5rem, calc(2vw / 0.48), 2rem);
          display: grid;
          gap: 1rem;

          .cart-heading {
            margin-bottom: 1rem;
          }

          .gastronomy-list {
            display: grid;
            gap: 0.75rem;
          }

          .add-gastronomy-normal {
            margin-top: 1rem;
            width: 100%;
          }

          // Empty state alert styling (copied from AlertTemplate pattern)
          .gastronomy-empty-alert {
            background-color: var(--neutral-100, #faf7f7);
            border-radius: clamp(0.5rem, calc(0.75vw / 0.48), 0.75rem);
            padding: 0.5rem 0.75rem;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0.5rem;
            z-index: 5;

            :global(strong) {
              color: var(--primary-800, #45051c);
              font-weight: 700;
            }

            :global(svg) {
              margin-top: 5px;
            }

            .alert-heading {
              letter-spacing: -0.03em;
              margin-bottom: 0.25rem;
            }

            .alert-paragraph {
              font-size: var(--typography-body-m, 0.875rem);
              line-height: 1.7;
              letter-spacing: -0.01em;
              margin-bottom: 0.75rem;
            }

            :global(.add-gastronomy-button) {
              margin-top: clamp(0.625rem, calc(1vw / 0.48), 1rem);
            }
          }

          // Hide/show states
          &.has-items {
            .gastronomy-empty-alert {
              display: none;
            }

            .add-gastronomy-normal {
              display: block;
            }
          }

          &.no-items {
            .gastronomy-empty-alert {
              display: grid;
            }

            .add-gastronomy-normal {
              display: none;
            }
          }

          @media (max-width: 31.1875rem) {
            // Responsive styles can be added here if needed
          }
        }
      }
    }

    @media (max-width: 49.9375rem) {
      .cart-container {
        padding-left: clamp(0.5rem, calc(2.75vw / 0.48), 2.75rem);
        padding-right: clamp(0.5rem, calc(2.75vw / 0.48), 2.75rem);
        .items-wrapper {
          .extras {
            .list {
              display: flex;
              flex-direction: column;
            }
          }
        }
      }
    }

    @media (max-width: 32.4375rem) {
      .cart-container .items-wrapper .header {
        .inputs {
          flex-direction: column;

          .input-field.participants {
            max-width: 100%;
          }
        }
      }
    }

    @media (max-width: 29.3125rem) {
      .back-link {
        margin-left: 1rem;
      }
      .cart-container {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
        background-color: var(--neutral-200);

        &::after,
        &::before {
          display: none;
        }

        .extras {
          .show-more-wrapper {
            :global(> button) {
              max-width: 100%;
              width: 100%;

              display: flex;
              justify-content: center;
            }
          }
        }
      }
    }
  }

  :global(.popup-content) {
    max-width: 68rem;
    padding: 2.5rem;
    .extras-container {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1.5rem;
      overflow: hidden;
    }

    :global(h2) {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
      align-self: center;
      margin-top: 0.5rem;
    }

    :global(.CloseButton) {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
    }

    :global(.extras-list-wrapper) {
      grid-column: 1 / 3;
      grid-row: 2 / 3;
      display: flex;
      flex-direction: column;
      margin-top: 1rem;
      min-height: 0;
      max-height: 32.25rem;
      overflow-y: auto;

      @media (hover: hover) and (pointer: fine) {
        padding-right: 0.125rem;

        &::-webkit-scrollbar {
          width: 0.25rem;
        }

        &::-webkit-scrollbar-track {
          background: var(--neutral-300, #ede6de);
          border-radius: 16px;
        }

        &::-webkit-scrollbar-thumb {
          background: var(--primary-400, #74535e);
          border-radius: 16px;
        }

        &::-webkit-scrollbar-thumb:hover {
          background: var(--primary-700, #600d2a);
        }
      }
    }

    :global(.extras-list) {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(14rem, 1fr));
      gap: 0.25rem;
      align-items: start;
      flex-shrink: 0;
      overflow-y: auto;
    }

    @media (max-width: 49.9375rem) {
      :global(.extras-list) {
        display: flex;
        flex-direction: column;
      }
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin) 0;
      width: 100vw !important;
    }
  }

  :global(.hidden-trigger) {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  :global(.gastronomy-popup) {
    display: grid;
    grid-template-columns: auto 1fr;
    grid-template-rows: auto 1fr;
    column-gap: 0.5rem;
    max-width: 46rem;
    margin: 0 auto;
    height: 100%;
    overflow: hidden;
    width: 100%;

    // Header row with heading and close button

    :global(h2) {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
      align-self: start;
    }

    :global(.CloseButton) {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
      justify-self: end;
      align-self: start;
    }

    .gastronomy-form {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      margin-top: 1rem;
      grid-column: 1/-1;

      .gastronomy-form-wrapper {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow-y: auto;
        overflow-x: clip;
        height: 100%;
      }

      .form-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;

        :global(label) {
          font-size: var(--typography-body-m, 0.875rem);
          font-weight: 700;
          color: var(--primary-800);
        }

        :global(select),
        :global(input[type='number']) {
          padding: 0.75rem;
          border: 1px solid var(--neutral-300);
          font-size: var(--typography-body-m, 0.875rem);
          background-color: var(--neutral-100);
        }

        .counter-control {
          display: flex;
          align-items: center;

          :global(button) {
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--neutral-100);
            border: 1px solid var(--neutral-300);
            cursor: pointer;
            transition: background-color 200ms;

            &:first-child {
              border-radius: 0.375rem 0 0 0.375rem;
              border-right: none;
            }

            &:last-child {
              border-radius: 0 0.375rem 0.375rem 0;
              border-left: none;
            }

            &:hover {
              background-color: var(--neutral-200);
            }

            &:focus-visible {
              outline: 2px solid var(--primary-400);
              outline-offset: 2px;
            }
          }

          :global(input[type='number']) {
            width: 4rem;
            text-align: center;
            border-left: 0;
            border-right: 0;
            border-radius: 0;
            padding: 0.75rem 0.5rem;

            &::-webkit-outer-spin-button,
            &::-webkit-inner-spin-button {
              -webkit-appearance: none;
              margin: 0;
            }

            &[type='number'] {
              -moz-appearance: textfield;
            }
          }
        }

        .radio-group {
          display: flex;
          gap: 1rem;

          :global(label) {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            cursor: pointer;

            :global(input[type='radio']) {
              width: 1rem;
              height: 1rem;
              accent-color: var(--primary-500);
            }
          }
        }
      }

      .meal-options {
        padding: 1rem;
        background-color: var(--neutral-100);
        border-radius: 0.375rem;
        border: 1px solid var(--neutral-300);
        gap: 0.75rem;
        display: flex;
        flex-direction: column;

        /* Animation when appearing */
        animation: fadeInFromLeft 400ms var(--easing) forwards;

        @keyframes fadeInFromLeft {
          from {
            opacity: 0;
            transform: translateX(-1rem);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        .form-field {
          display: flex;
          flex-direction: column;
          gap: 0.5rem;

          label {
            font-size: var(--typography-body-m, 0.875rem);
            font-weight: 700;
            color: var(--primary-800);
            margin: 0;
          }

          .radio-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;

            label {
              position: relative;
              display: flex;
              align-items: center;
              gap: 0.5rem;
              font-weight: 400;
              cursor: pointer;
              padding: 0.5rem 1rem;
              border-radius: var(--corner-radius-l, 999px);
              border: 1px solid var(--neutral-300);
              background-color: transparent;
              font-size: var(--typography-body-s, 0.75rem);
              color: var(--primary-700);
              min-height: 2.25rem;
              overflow: hidden;
              transition: border-color 200ms;
              isolation: isolate;

              &::before {
                content: '';
                position: absolute;
                inset: 0;
                background-color: var(--neutral-300);
                transform: scaleX(0);
                transition:
                  transform 350ms var(--easing),
                  background-color 200ms;
                transform-origin: left;
              }

              input {
                position: absolute;
                opacity: 0;
                width: 0;
                height: 0;
                margin: 0;
                pointer-events: none;
              }

              span {
                position: relative;
                z-index: 1;
                transition: color 200ms;
                font-weight: 500;
                line-height: 1;
              }

              &:hover {
                &::before {
                  transform: scale(1);
                }
              }

              &:has(input:focus-visible) {
                outline: 2px solid var(--primary-800);
                outline-offset: 2px;
              }

              &:has(input:checked) {
                border-color: var(--primary-500);

                &::before {
                  transform: scale(1);
                  background-color: var(--primary-500);
                }

                span {
                  color: var(--neutral-100);
                }
              }

              &:active {
                transform: translateY(0);
              }
            }
          }
        }
      }

      // Form error styling based on existing Error component
      .form-error {
        font-size: var(--typography-body-s, 0.75rem);
        color: var(--error-500, #c23d3d);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        margin-top: 0.25rem;
        animation: formErrorFadeIn 300ms var(--easing);

        @keyframes formErrorFadeIn {
          from {
            opacity: 0;
            transform: translateY(0.25rem);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        &::before {
          content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12' fill='none'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2.65586 5.38075C4.11504 2.79358 4.84463 1.5 6 1.5C7.15537 1.5 7.88496 2.79358 9.34414 5.38074L9.52597 5.70313C10.7385 7.85305 11.3448 8.92801 10.7969 9.71401C10.2489 10.5 8.89322 10.5 6.18183 10.5H5.81817C3.10678 10.5 1.75109 10.5 1.20313 9.71401C0.655171 8.92801 1.26146 7.85305 2.47403 5.70314L2.65586 5.38075ZM6 3.625C6.20711 3.625 6.375 3.79289 6.375 4V6.5C6.375 6.70711 6.20711 6.875 6 6.875C5.79289 6.875 5.625 6.70711 5.625 6.5V4C5.625 3.79289 5.79289 3.625 6 3.625ZM6 8.5C6.27614 8.5 6.5 8.27614 6.5 8C6.5 7.72386 6.27614 7.5 6 7.5C5.72386 7.5 5.5 7.72386 5.5 8C5.5 8.27614 5.72386 8.5 6 8.5Z' fill='%23AA0B50'/%3E%3C/svg%3E");
          display: inline-block;
          margin-top: 4px;
        }
      }

      // Label with inline error layout
      .label-with-error {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.25rem 0.75rem;
        margin-bottom: 0.5rem;
        width: 100%;
        flex-wrap: wrap;

        label,
        .meal-options-title {
          font-size: var(--typography-body-m, 0.875rem);
          font-weight: 700;
          color: var(--primary-800);
          margin: 0;
          flex-shrink: 0;
        }

        .meal-options-title {
          font-size: var(--typography-body-m, 0.875rem);
          font-weight: 700;
          color: var(--primary-800);
          margin: 0;
        }

        .form-error {
          margin-top: 0;
          flex-shrink: 0;
        }
      }

      .form-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: clamp(1.25rem, calc(1.5vw / 0.48), 1.5rem);
        padding: 0 2px 2px 2px;

        :global(button) {
          flex: 1;
          max-width: none;

          &[data-theme='primary'][data-shade='light'] {
            :global(span) {
              margin: 0 auto;
              padding-right: 1.75rem;
            }
          }

          &[data-theme='primary'][data-shade='dark'] {
            :global(span) {
              margin: 0 auto;
              padding-right: 1.75rem;
            }
          }
        }
      }
    }

    @media (max-width: 41.0625rem) {
      .gastronomy-form .form-actions {
        flex-direction: column;
        gap: 0.5rem;
      }
    }

    @media (max-width: 31.1875rem) {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      .gastronomy-form {
        padding-bottom: 1rem;
        .form-field .service-type-grid {
          gap: 0.375rem;
        }
      }
    }
  }
  :global(.address-popup) {
    display: grid;
    align-items: start;
    gap: 1rem 2rem;
    grid-template-columns: auto 1fr 1fr;
    overflow: hidden;
    grid-template-rows: auto 1fr;
    h2 {
      grid-column: 1/3;
      grid-row: 1/2;
    }

    :global(.CloseButton) {
      justify-self: end;
      grid-column: 3/4;
      grid-row: 1/2;
    }

    .address-form-container {
      grid-column: 1/-1;
      grid-row: 2/3;
      margin-bottom: 0;
      display: grid;
      grid-template-columns: auto 1fr;
      height: 100%;
      overflow-y: auto;
    }

    :global(.additional-info-block) {
      grid-column: 1/-1;
      grid-row: 2/3;
      margin-bottom: 1rem;
    }

    .address-form-wrapper {
      grid-column: 2/4;
      grid-row: 3/4;
      max-width: 26.25rem;

      .address-form-heading {
        color: var(--primary-800, #45051c);
        font-size: var(--typography-body-m, 0.875rem);
        font-weight: 700;
        line-height: 1.7;
        margin-bottom: 1rem;
      }
    }

    .transport-box {
      grid-column: 1/2;
      grid-row: 3/4;
      max-width: 15.125rem;
      display: grid;
      overflow: hidden;
      border-radius: 0.375rem;
      background-color: var(--neutral-100, #faf7f7);
      border: 1px solid var(--neutral-300, #ede6de);
      margin-right: 2rem;
      align-self: start;

      :global(img) {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      :global(h3) {
        padding: 0 1rem;
        margin: 1rem 0 0.75rem;
        color: var(--primary-800, #45051c);
        font-size: var(--typography-body-m, 0.875rem);
        line-height: 1.7;
        font-weight: 700;
      }

      .price-info {
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 0.125rem;
        padding: 0 1rem 1rem 1rem;
        line-height: 1.7;
        letter-spacing: -0.01em;
        font-size: var(--typography-body-m, 0.875rem);

        :global(strong) {
          color: var(--primary-800, #45051c);
        }

        .price {
          :global(strong) {
            font-size: var(--typography-body-xl, 1.125rem);
            letter-spacing: -0.03em;
            line-height: 1.5;
          }
        }

        .price-details {
          display: flex;
          align-items: flex-start;
          gap: 0.125rem;

          :global(svg) {
            flex-shrink: 0;
            margin-top: 5px;
          }
        }
      }
    }
    @media (max-width: 54.3125rem) {
      .transport-box {
        grid-column: 1/4;
        grid-row: 3/4;
        display: grid;
        grid-template-columns: auto auto 1fr;
        width: 100%;
        max-width: 100%;
        margin-bottom: 1rem;
        margin-right: 0;
        overflow: visible;
        :global(img) {
          grid-column: 1/2;
          grid-row: 1/2;
          width: 159px;
          min-height: 106px;
          height: 100%;
        }
        :global(h3) {
          grid-column: 2/3;
          grid-row: 1/2;
        }

        .price-info {
          justify-self: end;
          grid-column: 3/4;
          grid-row: 1/2;
          align-self: start;
          margin-top: 1rem;
        }
      }

      :global(.additional-info-block) {
        grid-column: 1/4;
        grid-row: 2/3;
      }

      .address-form-wrapper {
        grid-column: 1/4;
        grid-row: 4/5;
        max-width: 100%;

        :global(button[data-theme='primary']) {
          width: 100%;
          max-width: 100%;
          margin-top: 0.5rem;

          :global(span) {
            margin: 0 auto;
            padding-right: 1.75rem;
          }
        }
      }
    }

    @media (max-width: 46.1875rem) {
      padding: 1.5rem;
      h2 {
        grid-column: 1/2;
      }
      .transport-box {
        grid-template-columns: 1fr auto;
        :global(img) {
          grid-column: 2/3;
          grid-row: 1/2;
          margin-top: 0.5rem;
          margin-right: 0.5rem;
          border-radius: 0.25rem;
        }
        :global(h3) {
          grid-column: 1/2;
          grid-row: 1/2;
        }

        .price-info {
          margin-top: 0.5rem;
          border-top: 0.0625rem solid var(--neutral-300, #ede6de);
          padding-top: 0.5rem;
          grid-column: 1/3;
          grid-row: 2/3;
          justify-self: stretch;
          width: 100%;
        }
      }

      .address-form-wrapper {
      }
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin);
    }
  }

  :global(.removal-confirmation) {
    max-width: 36rem;
    margin: 0 auto;
    display: flex;
    gap: 0rem;
    flex-direction: column;

    :global(.CloseButton) {
      align-self: flex-end;
      margin-bottom: 1rem;
    }

    .title {
      color: var(--primary-800);
      margin-bottom: 1.25rem;
      font-size: var(--typography-body-2xl, 1.5rem);
      line-height: 1.25;
      letter-spacing: -0.035em;
      text-align: center;

      :global(strong) {
        font-weight: 700;
      }
    }

    .message {
      text-align: center;
      margin-bottom: 1.75rem;
    }

    .confirmation-actions {
      display: flex;
      gap: 1rem;
      :global(button) {
        max-width: 100%;
        width: 100%;

        &[data-theme='primary'] {
          :global(span) {
            margin: 0 auto;
            padding-right: 1.75rem;
          }
        }
      }
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin);

      :global(.CloseButton) {
        margin-bottom: 0;
      }

      .confirmation-actions {
        flex-direction: column;
      }
    }
  }

  :global(select),
  :global(input[type='number']) {
    padding: 0.75rem;
    border: 1px solid var(--neutral-300);
    font-size: var(--typography-body-m, 0.875rem);
    background-color: var(--neutral-100);
  }

  .service-type-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
  }

  .service-type-option {
    position: relative;
    cursor: pointer;
    background-color: var(--neutral-100);
    border: 1px solid var(--neutral-300);
    border-radius: 0.375rem;
    padding: 0.75rem;

    &:hover {
      .option-title {
        transform: translateX(0.25rem);
      }
    }

    input[type='checkbox'] {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      width: 1rem;
      height: 1rem;
      accent-color: var(--primary-500);
      cursor: pointer;
    }

    .option-content {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      position: relative;

      &::before {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%) scale(0);
        width: 0.875rem;
        height: 0.875rem;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' fill='none'%3E%3Cpath fill='%23F67258' fill-rule='evenodd' d='M12.83 7A5.833 5.833 0 1 1 1.165 7a5.833 5.833 0 0 1 11.667 0ZM9.349 5.232c.171.171.171.448 0 .62L6.432 8.767a.437.437 0 0 1-.619 0L4.646 7.6a.438.438 0 0 1 .62-.619l.856.858 1.304-1.304L8.73 5.232c.17-.17.448-.17.618 0Z' clip-rule='evenodd'/%3E%3C/svg%3E");
        background-size: contain;
        background-repeat: no-repeat;
        transition: transform 300ms cubic-bezier(0.18, 0.89, 0.32, 1.27);
        opacity: 0;
      }

      .option-title {
        font-size: var(--typography-body-m, 0.875rem);
        font-weight: 600;
        color: var(--primary-800);
        line-height: 1.4;
        transition: transform 300ms cubic-bezier(0.18, 0.89, 0.32, 1.27);
      }
    }

    &:has(input:checked) {
      .option-content {
        &::before {
          transform: translateY(-50%) scale(1);
          opacity: 1;
        }

        .option-title {
          transform: translateX(1.25rem);
        }
      }
    }

    &:has(input:focus-visible) {
      outline: 2px solid var(--primary-800);
      outline-offset: 2px;

      input[type='radio'] {
        outline: none;
      }
    }
  }

  input[type='radio'] {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    width: 1rem;
    height: 1rem;
    accent-color: var(--primary-500);
    cursor: pointer;
  }

  .quantity-control {
    display: flex;
    align-items: center;

    button {
      width: 2.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--neutral-100);
      border-radius: 0.25rem;
      cursor: pointer;
      border: 1px solid var(--neutral-300, #ede6de);
      min-height: 2.75rem;
      transition: background-color 200ms;

      &:first-of-type {
        order: 1;
        border-radius: 0.3rem 0 0 0.3rem;
        border-right: none;
      }

      &:last-of-type {
        order: 3;
        border-radius: 0 0.3rem 0.3rem 0;
        border-left: none;
      }

      &:hover {
        background-color: var(--neutral-200);
      }

      &:focus-visible {
        outline: 2px solid var(--primary-400);
        outline-offset: 2px;
      }
    }

    .quantity-input {
      width: 2.75rem;
      height: 2.75rem;
      text-align: center;
      border: 1px solid var(--neutral-300);
      border-right: 0;
      border-left: 0;
      padding: 0;
      background-color: var(--neutral-100);
      font-size: var(--typography-body-m, 0.875rem);
      transition: background-color 200ms;
      order: 2;
      line-height: 1;
      letter-spacing: -0.01em;
      -moz-appearance: textfield;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;

      &::-webkit-outer-spin-button,
      &::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      &:hover {
        background-color: var(--neutral-200);
      }

      &:focus {
        outline: none !important;
        border: 2px solid var(--primary-800);
      }

      &:focus-visible {
        outline: 2px solid var(--primary-400);
        border-color: var(--primary-400);
      }
    }
  }

  :global(.activity-address-popup) {
    display: grid;
    align-items: start;
    gap: 1rem 2rem;
    grid-template-columns: 1fr auto;
    max-width: 42rem;

    h2 {
      grid-column: 1/2;
      grid-row: 1/2;
    }

    :global(.CloseButton) {
      justify-self: end;
      grid-column: 2/3;
      grid-row: 1/2;
    }

    .activity-address-form-wrapper {
      grid-column: 1/3;
      grid-row: 2/3;

      .activity-form-heading {
        color: var(--primary-800, #45051c);
        font-size: var(--typography-body-m, 0.875rem);
        font-weight: 700;
        line-height: 1.7;
        margin-bottom: 1rem;
      }
    }

    @media (max-width: 46.1875rem) {
      padding: 1.5rem;
      max-width: 100%;
    }

    @media (max-width: 31.1875rem) {
      padding: 1.5rem var(--pageMargin);
      width: 100vw !important;
    }
  }

  // Utility classes
  .hidden {
    display: none;
  }
</style>

<script>
  import type { Alert } from '@/src/global/types'
  import { cartStore } from '@/src/store/cart'
  import type { AddonItem } from '@/src/store/cart'
  import {
    renderHotel,
    renderActivity,
    renderAlerts,
    type ExtendedHotelData,
    type ExtendedActivityData,
  } from '@/src/utils/cart'
  import { optimizeImage } from '@/src/utils/optimize-images'
  import { showToast } from '@/src/utils/toast'
  import { trackEvent } from '@/src/pages/api/analytics/track-event'

  const cartElement = document.querySelector('.Cart') as HTMLElement
  const lang = cartElement?.getAttribute('data-lang') || 'pl'
  const t = JSON.parse(cartElement?.getAttribute('data-translations') || '{}') as Record<string, any>

  // Add loading state protection
  let isLoadingCartItems = false
  let loadCartItemsTimeout: number | null = null

  // Helper to get current active state
  function getActiveState(): 'loading' | 'empty' | 'error' | 'content' {
    const states = ['loading', 'empty', 'error', 'content'] as const

    for (const state of states) {
      const stateEl = document.querySelector(`.state-${state}`) as HTMLElement | null
      if (stateEl && window.getComputedStyle(stateEl).display !== 'none') {
        return state
      }
    }

    return 'loading' // Default
  }

  // Function to dynamically sync peoplePerBus with participant count
  function syncTransportPeopleWithParticipants(participantCount: number) {
    // Set peoplePerBus to match participant count (minimum 1)
    const newPeoplePerBus = Math.max(participantCount || 1, 1)

    // Always store peoplePerBus in localStorage (independent of transport selection)
    localStorage.setItem('cart_people_per_bus', newPeoplePerBus.toString())

    // Also update transport address data if it exists
    const transportAddress = localStorage.getItem('transport_address')
    if (transportAddress) {
      try {
        const addressData = JSON.parse(transportAddress)

        // Update the address data
        const updatedAddressData = {
          ...addressData,
          peoplePerBus: newPeoplePerBus,
        }

        // Save updated data to localStorage
        localStorage.setItem('transport_address', JSON.stringify(updatedAddressData))
      } catch (error) {
        console.error('Error updating transport address data:', error)
      }
    }

    // Always dispatch event to notify the form component
    window.dispatchEvent(
      new CustomEvent('transport-people-synced', {
        detail: {
          newPeoplePerBus: newPeoplePerBus,
          participantCount: participantCount,
        },
      })
    )
  }

  // Function to update participant alerts based on current count
  function updateParticipantAlerts() {
    // Only run if content state is visible
    if (getActiveState() !== 'content') return

    const participantInput = document.getElementById('participantCount') as HTMLInputElement

    // First check if we have value in localStorage, and use that if available
    const savedCount = localStorage.getItem('cart_participant_count')
    let participantCount = 0

    if (savedCount) {
      participantCount = parseInt(savedCount)
      // Make sure the input value matches localStorage
      if (participantInput) {
        participantInput.value = savedCount
      }
    } else if (participantInput) {
      // Fallback to the input value if no localStorage value exists
      participantCount = parseInt(participantInput.value || '0')
    }

    // Find all hotel items in the cart
    const hotelItems = document.querySelectorAll('.state-content .hotel-item')

    hotelItems.forEach((item) => {
      const itemId = item.getAttribute('data-item-id')
      const maxPeople = parseInt(item.getAttribute('data-max-people') || '0')

      if (!itemId || !maxPeople) return

      const alertsList = item.querySelector('.alerts')
      if (!alertsList) return

      // Remove any existing participant alerts
      const existingAlerts = alertsList.querySelectorAll('.participant-alert')
      existingAlerts.forEach((alert) => alert.remove())

      // If count exceeds max, add a new alert
      if (participantCount > maxPeople) {
        // Create a custom alert object
        const participantAlert: Alert = {
          heading: t.participantExceedsMaxAlert.heading.replace('{maxPeople}', String(maxPeople)),
          paragraph: t.participantExceedsMaxAlert.paragraph.replace('{maxPeople}', String(maxPeople)),
          cta: {
            text: t.participantExceedsMaxAlert.cta.text,
            internalReference: {
              slug: t.participantExceedsMaxAlert.cta.href,
            } as any,
          },
        }

        // Use the exported renderAlerts function with a custom class
        renderAlerts([participantAlert], alertsList, 'participant-alert')
      }
    })

    const activityItems = document.querySelectorAll('.state-content .activity-item')

    activityItems.forEach((item) => {
      const itemId = item.getAttribute('data-item-id')
      const maxPeople = parseInt(item.getAttribute('data-max-people') || '0')
      const minPeople = parseInt(item.getAttribute('data-min-people') || '0')

      if (!itemId || !maxPeople || !minPeople) return

      const alertsList = item.querySelector('.alerts')
      if (!alertsList) return

      // Remove any existing participant alerts
      const existingAlerts = alertsList.querySelectorAll('.activity-participant-alert')
      existingAlerts.forEach((alert) => alert.remove())

      // If count exceeds max, add a new alert
      if (participantCount > maxPeople) {
        // Create a custom alert object
        const participantAlert: Alert = {
          heading: t.activityParticipantExceedsMaxAlert.heading.replace('{maxPeople}', String(maxPeople)),
          paragraph: t.activityParticipantExceedsMaxAlert.paragraph.replace('{maxPeople}', String(maxPeople)),
          cta: {
            text: t.activityParticipantExceedsMaxAlert.cta.text,
            internalReference: {
              slug: t.activityParticipantExceedsMaxAlert.cta.href,
            } as any,
          },
        }

        // Use the exported renderAlerts function with a custom class
        renderAlerts([participantAlert], alertsList, 'activity-participant-alert')
      }

      if (participantCount < minPeople) {
        const participantAlert: Alert = {
          heading: t.activityParticipantBelowMinAlert.heading.replace('{minPeople}', String(minPeople)),
          paragraph: t.activityParticipantBelowMinAlert.paragraph.replace('{minPeople}', String(minPeople)),
          cta: {
            text: t.activityParticipantBelowMinAlert.cta.text,
            internalReference: {
              slug: t.activityParticipantBelowMinAlert.cta.href,
            } as any,
          },
        }

        renderAlerts([participantAlert], alertsList, 'activity-participant-alert')
      }
    })
  }

  // Create fetch functions for hotels and activities
  async function fetchHotelData(id: string, addonIds: string[] = []) {
    try {
      const addonIdsParam = addonIds.length > 0 ? `&addonIds=${addonIds.join(',')}` : ''
      const response = await fetch(`/api/cart/hotel?id=${id}&lang=${lang}${addonIdsParam}`)
      if (!response.ok) throw new Error('Failed to fetch hotel data')
      return await response.json()
    } catch (error) {
      console.error('Error fetching hotel:', error)
      return null
    }
  }

  async function fetchActivityData(id: string, addonIds: string[] = []) {
    try {
      const addonIdsParam = addonIds.length > 0 ? `&addonIds=${addonIds.join(',')}` : ''
      const response = await fetch(`/api/cart/activity?id=${id}&lang=${lang}${addonIdsParam}`)
      if (!response.ok) throw new Error('Failed to fetch activity data')
      return await response.json()
    } catch (error) {
      console.error('Error fetching activity:', error)
      return null
    }
  }

  // Function to update gastronomy section visibility based on hotels
  function updateGastronomySectionVisibility() {
    const gastronomySection = document.querySelector('.gastronomy-section') as HTMLElement
    const cart = cartStore.get()
    const hasHotels = cart.hotels.length > 0

    if (gastronomySection) {
      if (hasHotels) {
        gastronomySection.style.display = 'block'
      } else {
        gastronomySection.style.display = 'none'
      }
    }
  }

  // Function to render all cart items
  async function renderCartItems(hotels: ExtendedHotelData[], activities: ExtendedActivityData[]) {
    const cartContent = document.querySelector('.cart-container')! as HTMLDivElement
    const cartHeadingCount = document.querySelector('.state-content .header .cart-heading .count')! as HTMLSpanElement

    if (!cartContent) return

    // Render hotels section
    const hotelsSection = cartContent.querySelector('.hotels-section')! as HTMLDivElement
    const hotelList = hotelsSection.querySelector('.list')! as HTMLDivElement
    const hotelsCount = hotelsSection.querySelector('.count')! as HTMLSpanElement

    // Clear existing hotels before rendering new ones
    hotelList.innerHTML = ''

    if (hotels && hotels.length > 0) {
      const hotelPromises = hotels.map(async (hotel) => {
        const hotelElement = await renderHotel(hotel, t)
        return hotelElement
      })
      const hotelElements = await Promise.all(hotelPromises)
      hotelElements.forEach((hotelElement) => {
        if (hotelElement) {
          // Check if item already exists before appending (additional safety)
          const hotelItem = hotelElement.querySelector('.hotel-item')
          const itemId = hotelItem?.getAttribute('data-item-id')

          if (itemId) {
            const existingItem = hotelList.querySelector(`[data-item-id="${itemId}"]`)
            if (!existingItem) {
              hotelList.appendChild(hotelElement)
            }
          } else {
            // Fallback if no item ID found
            hotelList.appendChild(hotelElement)
          }
        }
      })
      hotelsCount.textContent = hotels.length.toString()
    } else if (activities && activities.length > 0) {
      // If we have activities but no hotels, show the empty hotels alert
      hotelsCount.textContent = '0'
      renderEmptySectionAlert(hotelList, 'hotels')
    }

    // Render activities section
    const activitiesSection = cartContent.querySelector('.activities-section')! as HTMLDivElement
    const activitiesList = activitiesSection.querySelector('.list')! as HTMLDivElement
    const activitiesCount = activitiesSection.querySelector('.count')! as HTMLSpanElement

    // Clear existing activities before rendering new ones
    activitiesList.innerHTML = ''

    if (activities && activities.length > 0) {
      const activityPromises = activities.map(async (activity) => {
        const activityElement = await renderActivity(activity, t)
        return activityElement
      })
      const activityElements = await Promise.all(activityPromises)
      activityElements.forEach((activityElement) => {
        if (activityElement) {
          // Check if item already exists before appending (additional safety)
          const activityItem = activityElement.querySelector('.activity-item')
          const itemId = activityItem?.getAttribute('data-item-id')

          if (itemId) {
            const existingItem = activitiesList.querySelector(`[data-item-id="${itemId}"]`)
            if (!existingItem) {
              activitiesList.appendChild(activityElement)
            }
          } else {
            // Fallback if no item ID found
            activitiesList.appendChild(activityElement)
          }
        }
      })
      activitiesCount.textContent = activities.length.toString()
    } else if (hotels && hotels.length > 0) {
      // If we have hotels but no activities, show the empty activities alert
      activitiesCount.textContent = '0'
      renderEmptySectionAlert(activitiesList, 'activities')
    }

    cartHeadingCount.textContent = `${hotels.length + activities.length}`

    // Update gastronomy section visibility based on hotels
    updateGastronomySectionVisibility()
  }

  // Function to render empty section alerts
  function renderEmptySectionAlert(container: HTMLElement, sectionType: 'hotels' | 'activities') {
    const template = document.getElementById('alert-template') as HTMLTemplateElement
    if (!template) return

    const clone = template.content.cloneNode(true) as DocumentFragment
    const alertDiv = clone.querySelector('.alert-item') as HTMLElement

    const headingEl = alertDiv.querySelector('.alert-heading') as HTMLElement
    const paragraphEl = alertDiv.querySelector('.alert-paragraph') as HTMLElement
    const linkEl = alertDiv.querySelector('a') as HTMLAnchorElement
    const linkElText = linkEl.querySelector('span') as HTMLElement

    // Set content based on section type and translations
    headingEl.innerHTML = t.emptySection[sectionType].heading
    paragraphEl.innerHTML = t.emptySection[sectionType].paragraph

    linkEl.href = sectionType === 'hotels' ? t.hotelsPrefix : t.activitiesPrefix
    linkElText.innerHTML = t.emptySection[sectionType].button

    // Append to container
    container.appendChild(alertDiv)
  }

  // Function to rebuild the extras list in real-time
  async function refreshExtrasList(): Promise<void> {
    // Re-get everything from the beginning to ensure correct order
    await loadCartExtras()
  }

  // Function to handle transport selection
  async function handleTransportToggle(item: HTMLElement, isSelected: boolean) {
    // NEW: Check if participants are set before allowing transport selection
    if (isSelected) {
      const participantInput = document.getElementById('participantCount') as HTMLInputElement
      const participantCount = participantInput?.value ? parseInt(participantInput.value) : 0

      if (!participantCount) {
        // Show error toast and don't proceed
        showToast(t.missingParticipantsForTransport, 'error')

        // Reset checkbox state
        const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
        if (checkbox) {
          checkbox.checked = false
        }
        item.setAttribute('data-selected', 'false')

        return false
      }
    }

    // isSelected is the target state - if true, we're adding transport, if false, we're removing it

    // If removing transport (unchecking), show confirmation popup
    if (!isSelected) {
      // Open confirmation popup
      const transportRemoveTrigger = document.getElementById('transport-remove-trigger')

      // Store reference to the item to remove if confirmed
      localStorage.setItem('pending_transport_removal', item.dataset.addonId || '')

      // Open the popup
      if (transportRemoveTrigger) {
        transportRemoveTrigger.click()
      }

      // Don't remove yet - wait for confirmation
      return false
    }

    // If adding transport (checking), open address popup
    const transportTrigger = document.getElementById('transport-address-trigger')
    if (transportTrigger) {
      // Store current item reference for the form submission handler
      localStorage.setItem('pending_transport_item', item.dataset.addonId || '')

      transportTrigger.click()
    }

    // Don't select yet - this will happen after address submission
    return false
  }

  // Setup transport removal confirmation
  function setupTransportRemovalConfirmation() {
    const confirmBtn = document.querySelector('.confirm-transport-remove')
    const cancelBtn = document.querySelector('.cancel-transport-remove')
    const closeBtn = document.querySelector('.removal-confirmation .CloseButton')

    if (confirmBtn) {
      confirmBtn.addEventListener('click', () => {
        const pendingId = localStorage.getItem('pending_transport_removal')
        if (pendingId) {
          // Find the transport item
          const transportItem = document.querySelector(`.extra-item[data-addon-id="${pendingId}"]`) as HTMLElement

          if (transportItem) {
            // Actually remove transport
            toggleAddon(transportItem, false)

            // Remove the address data from localStorage
            localStorage.removeItem('transport_address')

            // Show toast notification with translated message
            showToast(t.transportRemoval.successToast, 'success')
          }

          // Remove pending ID
          localStorage.removeItem('pending_transport_removal')
        }

        // Close the popup
        if (closeBtn && closeBtn instanceof HTMLElement) {
          closeBtn.click()
        }
      })
    }

    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        // Reset any checkbox state that might have been visually changed
        const pendingId = localStorage.getItem('pending_transport_removal')
        if (pendingId) {
          const transportItems = document.querySelectorAll(`.extra-item[data-addon-id="${pendingId}"]`)
          transportItems.forEach((item) => {
            const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
            if (checkbox) {
              checkbox.checked = true
            }
            item.setAttribute('data-selected', 'true')
          })

          // Remove pending ID
          localStorage.removeItem('pending_transport_removal')
        }

        // Close the popup
        if (closeBtn && closeBtn instanceof HTMLElement) {
          closeBtn.click()
        }
      })
    }
  }

  // Function to update transport cards with address display
  function updateTransportCardWithAddress() {
    const transportItems = document.querySelectorAll('.extra-item[data-addon-id="transport"]')
    const addressData = JSON.parse(localStorage.getItem('transport_address') || '{}')

    transportItems.forEach((item) => {
      // Remove existing address display if any
      const existingAddress = item.querySelector('[data-address-display]')
      if (existingAddress) existingAddress.remove()

      // Only add address display if transport is selected and address exists
      const isSelected = item.getAttribute('data-selected') === 'true'
      if (!isSelected || Object.keys(addressData).length === 0) return

      // Create address display
      const addressDisplay = document.createElement('div')
      addressDisplay.setAttribute('data-address-display', '')

      const addressText = document.createElement('p')
      addressText.setAttribute('data-address-text', '')
      addressText.innerHTML = `
        <span>${addressData.street}, ${addressData.city}, (${addressData.postal})</span>
      `

      const editIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 17" fill="none"
              ><path
                fill="#F67258"
                d="M14.128 2.205a1.835 1.835 0 0 1 0 2.596l-.33.33a3.074 3.074 0 0 1-.356-.1 3.46 3.46 0 0 1-1.312-.828 3.46 3.46 0 0 1-.827-1.312 3.09 3.09 0 0 1-.1-.355l.33-.33a1.835 1.835 0 0 1 2.595 0ZM9.719 9.21c-.27.27-.404.404-.553.52a3.058 3.058 0 0 1-.565.349c-.17.081-.35.141-.712.262l-1.906.635a.495.495 0 0 1-.626-.626l.636-1.906c.12-.361.18-.542.261-.712.096-.2.213-.39.35-.565.115-.148.25-.283.52-.552L10.4 3.337a4.467 4.467 0 0 0 1.022 1.573c.538.538 1.11.847 1.573 1.022L9.72 9.21Z"
              ></path><path
                fill="#F67258"
                d="M13.69 14.025c.975-.976.975-2.548.975-5.69 0-1.033 0-1.895-.034-2.623l-4.242 4.241c-.234.235-.41.41-.608.565a4.057 4.057 0 0 1-.75.464c-.226.108-.463.186-.777.291l-1.954.652a1.495 1.495 0 0 1-1.891-1.891l.651-1.955c.105-.314.184-.55.292-.777.126-.266.282-.517.463-.75.155-.198.33-.374.565-.608l4.241-4.241c-.727-.035-1.59-.035-2.622-.035-3.143 0-4.714 0-5.69.976-.977.977-.977 2.548-.977 5.69 0 3.143 0 4.715.976 5.691.977.976 2.548.976 5.69.976 3.143 0 4.715 0 5.691-.976Z"
              ></path></svg
            >`

      const editButton = document.createElement('button')
      editButton.setAttribute('data-edit-address-button', '')
      editButton.innerHTML = `<div>${editIcon} ${editIcon}</div>  <span>${t.addressForm.editButton}</span>`
      editButton.addEventListener('click', (e) => {
        e.stopPropagation()
        // Open popup to edit address
        document.getElementById('transport-address-trigger')?.click()
      })

      // Add edit button first, then address text
      addressDisplay.appendChild(editButton)
      addressDisplay.appendChild(addressText)

      // Add to item after price info
      item.appendChild(addressDisplay)
    })
  }

  // Listen for the custom event from the React form
  document.addEventListener('address-form-submitted', (event: Event) => {
    const customEvent = event as CustomEvent
    const data = customEvent.detail?.data

    if (!data) return

    // Get pending transport item and select it
    const pendingItemId = localStorage.getItem('pending_transport_item')
    if (pendingItemId) {
      // Find all transport items (both in main list and popup)
      const transportItems = document.querySelectorAll(
        `.extra-item[data-addon-id="${pendingItemId}"]`
      ) as NodeListOf<HTMLElement>

      transportItems.forEach((item) => {
        // Update the item's state
        const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
        if (checkbox) {
          checkbox.checked = true
        }
        item.dataset.selected = 'true'

        // If this is the main list item, call toggleAddon on it
        if (!item.dataset.inPopup) {
          toggleAddon(item, true)
        }
      })

      localStorage.removeItem('pending_transport_item')
    }

    // Update transport card to show address with delay
    setTimeout(() => {
      updateTransportCardWithAddress()
    }, 200)
  })

  // Setup address form events
  function setupAddressForm() {
    // No need to do anything here as the React component handles everything
  }

  // Setup state management and retry button
  function setupStateManagement() {
    // Setup retry button
    const retryButton = document.getElementById('retry-load-cart')
    if (retryButton) {
      retryButton.addEventListener('click', () => {
        showState('loading')
        loadCartItems(true) // Pass true to indicate this is a retry
      })
    }

    // Add navigation buttons to empty state buttons if needed
    const emptyStateButtons = document.querySelectorAll('.state-empty .cta-buttons button') as NodeListOf<HTMLElement>
    emptyStateButtons.forEach((btn) => {
      if (btn.hasAttribute('href')) {
        btn.addEventListener('click', () => {
          const href = btn.getAttribute('href')
          if (href) {
            window.location.href = href
          }
        })
      }
    })
  }

  // Participant count handling
  function initParticipantInput() {
    const participantInput = document.getElementById('participantCount') as HTMLInputElement
    if (!participantInput) return

    // Load saved value from localStorage if available
    const savedCount = localStorage.getItem('cart_participant_count')
    if (savedCount) {
      participantInput.value = savedCount
    }

    // Handle input changes
    participantInput.addEventListener('input', () => {
      // Clean input - remove non-numeric values
      let value = participantInput.value.replace(/[^\d]/g, '')

      // Ensure value is at least 1
      if (!value || parseInt(value) < 1) {
        value = value || '' // Keep empty if it was empty
      }

      // Update input value
      participantInput.value = value

      // Only store in localStorage if we have a value
      if (value) {
        const newParticipantCount = parseInt(value)
        localStorage.setItem('cart_participant_count', value)

        // Check and auto-adjust transport settings if needed
        syncTransportPeopleWithParticipants(newParticipantCount)

        // Dispatch custom event to notify form components
        window.dispatchEvent(
          new CustomEvent('cart-participant-updated', {
            detail: { participantCount: newParticipantCount },
          })
        )
      } else {
        // If the field was cleared, remove from localStorage
        localStorage.removeItem('cart_participant_count')

        // Sync transport people to 1 when participants are empty (if transport is selected)
        syncTransportPeopleWithParticipants(0)

        // Dispatch custom event for cleared state
        window.dispatchEvent(
          new CustomEvent('cart-participant-updated', {
            detail: { participantCount: 0 },
          })
        )
      }

      // Update alerts when participant count changes
      updateParticipantAlerts()
    })

    // Handle blur to format value properly
    participantInput.addEventListener('blur', () => {
      let value = participantInput.value

      if (value) {
        // Convert to integer
        const intValue = parseInt(value)

        // Update with parsed integer value
        if (!isNaN(intValue)) {
          participantInput.value = intValue.toString()
          localStorage.setItem('cart_participant_count', intValue.toString())

          // Check and auto-adjust transport settings if needed
          syncTransportPeopleWithParticipants(intValue)

          // Dispatch custom event to notify form components
          window.dispatchEvent(
            new CustomEvent('cart-participant-updated', {
              detail: { participantCount: intValue },
            })
          )

          // Update alerts on blur
          updateParticipantAlerts()
        }
      }
    })
  }

  // Function to proceed with quote submission after getting activity address
  async function proceedWithQuoteSubmission() {
    try {
      // Get selected date(s)
      const cartDates = localStorage.getItem('cart_dates')
      let selectedDates: any[] = []
      if (cartDates) {
        try {
          selectedDates = JSON.parse(cartDates)
        } catch (e) {
          console.error('Error parsing cart dates:', e)
        }
      }

      // Validate that at least one date is selected
      if (!selectedDates || selectedDates.length === 0) {
        showToast(t.missingDates, 'error')
        return
      }

      // Get participant count and validate
      const participantInput = document.getElementById('participantCount') as HTMLInputElement
      const participantCount = participantInput?.value ? parseInt(participantInput.value) : 0

      // Validate that participant count is not empty
      if (!participantCount) {
        showToast(t.missingParticipants, 'error')
        return
      }

      // Track begin_checkout event
      const items = getCartItemsForTracking()

      trackEvent({
        ga: {
          event_name: 'begin_checkout',
          params: {
            currency: 'PLN',
            value: items
              .filter((item) => item.item_category === 'hotel' || item.item_category === 'activity')
              .reduce((acc, item) => acc + item.item_price, 0),
            items: items.map((item) => ({
              item_id: item.item_id,
              item_name: item.item_name,
            })),
          },
        },
        meta: {
          event_name: 'InitiateCheckout',
          content_name: document.title,
          params: {
            content_ids: items.map((item) => item.item_id),
          },
        },
      })

      // Scroll to top immediately when clicking submit
      window.scrollTo({
        top: 0,
        behavior: 'instant',
      })

      // Show submit-loading state
      showState('submit-loading')

      // Get cart data
      const cart = cartStore.get()

      // Fetch complete data for hotels with pricing and addons
      let validHotels = []
      let validActivities = []

      // If all necessary data is already in cache, use it
      if (cachedCartData.isComplete()) {
        validHotels = cachedCartData.hotels.map((hotel) => {
          // Format the hotel data for quote
          const addons =
            hotel.cartAddons?.map((addon) => {
              return {
                id: addon.id,
                name: addon.fullData?.name || 'Unknown',
                pricing: addon.fullData?.pricing,
                count: addon.count || 1,
              }
            }) || []

          return {
            id: hotel._id,
            type: 'hotel',
            name: hotel.name,
            slug: hotel.slug,
            pricing: hotel.pricing,
            maxPeople: hotel.maxPeople,
            addons,
            address: hotel.address,
            gastronomy: hotel.gastronomy, // Include gastronomy data from cached hotel
          }
        })

        validActivities = cachedCartData.activities.map((activity) => {
          // Format the activity data for quote
          const addons =
            activity.cartAddons?.map((addon) => {
              return {
                id: addon.id,
                name: addon.fullData?.name || 'Unknown',
                pricing: addon.fullData?.pricing,
                count: addon.count || 1,
              }
            }) || []

          return {
            id: activity._id,
            type: 'activity',
            name: activity.name,
            slug: activity.slug,
            pricing: activity.pricing,
            participantsCount: activity.participantsCount,
            addons,
            location: activity.location, // Include location data
          }
        })
      } else {
        // If cache is not complete, fetch data (this is a backup but shouldn't happen)

        // Fetch hotels data
        const hotelsPromises = cart.hotels.map(async (hotelItem) => {
          const addonIds = hotelItem.addOns.map((addon) => addon.id)
          const hotelData = await fetchHotelData(hotelItem.id, addonIds)

          if (!hotelData) return null

          // Map addons with their counts from the cart
          const addons =
            hotelData.addons?.addonsList?.map((addon: any) => {
              const cartAddon = hotelItem.addOns.find((a: { id: string }) => a.id === addon._key)
              return {
                id: addon._key,
                name: addon.name,
                pricing: addon.pricing,
                count: cartAddon?.count || 1,
              }
            }) || []

          return {
            id: hotelItem.id,
            type: 'hotel',
            name: hotelData.name,
            slug: hotelData.slug,
            pricing: hotelData.pricing,
            maxPeople: hotelData.maxPeople,
            addons,
            gastronomy: hotelData.gastronomy, // Include gastronomy data from fetched hotel
          }
        })

        // Fetch activities data
        const activitiesPromises = cart.activities.map(async (activityItem) => {
          const addonIds = activityItem.addOns.map((addon) => addon.id)
          const activityData = await fetchActivityData(activityItem.id, addonIds)

          if (!activityData) return null

          // Map addons with their counts from the cart
          const addons =
            activityData.addons?.addonsList?.map((addon: any) => {
              const cartAddon = activityItem.addOns.find((a: { id: string }) => a.id === addon._key)
              return {
                id: addon._key,
                name: addon.name,
                pricing: addon.pricing,
                count: cartAddon?.count || 1,
              }
            }) || []

          return {
            id: activityItem.id,
            type: 'activity',
            name: activityData.name,
            slug: activityData.slug,
            pricing: activityData.pricing,
            participantsCount: activityData.participantsCount,
            addons,
            location: activityData.location, // Include location data
          }
        })

        // Wait for all fetch operations to complete
        const [hotels, activities] = await Promise.all([Promise.all(hotelsPromises), Promise.all(activitiesPromises)])

        // Filter out null values (failed fetches)
        validHotels = hotels.filter(Boolean)
        validActivities = activities.filter(Boolean)
      }

      // Get transport address if exists
      const transportAddress = JSON.parse(localStorage.getItem('transport_address') || 'null')

      // Get activity address if exists (for activities without dedicated addresses)
      const activityAddress = JSON.parse(localStorage.getItem('activity_address') || 'null')

      // Get extras/addons
      const extrasIds = JSON.parse(localStorage.getItem('cart_order_addons') || '[]') as Array<{
        id: string
        count?: number
      }>

      // Get the extras data from the DOM that contains pricing information
      const extrasList = document.querySelector('.extras .list')
      const extrasData = JSON.parse(extrasList?.getAttribute('data-addons-data') || '{}')

      // Map the extras with their pricing data
      const extrasWithPricing = extrasIds.map((item: { id: string; count?: number }) => {
        if (item.id === 'transport') {
          return {
            id: item.id,
            count: item.count || 1,
            name: t.transportAddonName,
            pricing: extrasData.transportOptions.pricing,
            address: transportAddress,
          }
        } else {
          // Find the addon in the list
          const addonData = extrasData.addonsList.find(
            (addon: { _key: string; name: string; pricing: any }) => addon._key === item.id
          )
          return {
            id: item.id,
            count: item.count || 1,
            name: addonData?.name || 'Unknown Addon',
            pricing: addonData?.pricing || null,
          }
        }
      })

      // Prepare data payload
      const gastronomyData = JSON.parse(localStorage.getItem('cart_gastronomy_items') || '[]')

      const quoteData = {
        hotels: validHotels,
        activities: validActivities,
        participantCount,
        selectedDates,
        extras: extrasWithPricing,
        gastronomy: gastronomyData,
        language: lang,
        activityAddress: activityAddress, // Include activity address
      }

      // Add artificial delay for testing
      await new Promise((resolve) => setTimeout(resolve, 200))

      // Send data to API
      const response = await fetch('/api/quotes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(quoteData),
      })

      const result = await response.json()

      if (!result.success) {
        throw new Error(result.error || 'Failed to create quote')
      }

      // Redirect to quote page
      window.location.href = `/${lang}/koszyk?id=${result.quoteId}`
    } catch (error) {
      console.error('Error creating quote:', error)
      showState('submit-error')
    }
  }

  // Setup quote request handling
  function setupQuoteRequestHandling() {
    const getQuoteButton = document.getElementById('get-quote-button')
    const returnToCartButton = document.getElementById('return-to-cart')

    if (returnToCartButton) {
      returnToCartButton.addEventListener('click', () => {
        showState('content')
      })
    }

    if (!getQuoteButton) return

    getQuoteButton.addEventListener('click', async () => {
      try {
        // Get selected date(s)
        const cartDates = localStorage.getItem('cart_dates')
        let selectedDates: any[] = []
        if (cartDates) {
          try {
            selectedDates = JSON.parse(cartDates)
          } catch (e) {
            console.error('Error parsing cart dates:', e)
          }
        }

        // Validate that at least one date is selected
        if (!selectedDates || selectedDates.length === 0) {
          // Show error toast if no dates selected
          showToast(t.missingDates, 'error')
          return // Stop execution, don't proceed with API call
        }

        // Get participant count and validate
        const participantInput = document.getElementById('participantCount') as HTMLInputElement
        const participantCount = participantInput?.value ? parseInt(participantInput.value) : 0

        // Validate that participant count is not empty
        if (!participantCount) {
          showToast(t.missingParticipants, 'error')
          return
        }

        // NEW: Check if activity address is needed
        if (needsActivityAddress()) {
          // Show activity address popup
          const activityAddressTrigger = document.getElementById('activity-address-trigger')
          if (activityAddressTrigger) {
            activityAddressTrigger.click()
          }
          return // Wait for activity address submission
        }

        // If we reach here, proceed with quote submission using the shared function
        await proceedWithQuoteSubmission()
      } catch (error) {
        console.error('Error in submit handler:', error)
        showState('submit-error')
      }
    })
  }

  // Initialize document event listeners
  document.addEventListener('DOMContentLoaded', () => {
    // Setup state management first
    setupStateManagement()

    // Initialize participant input to ensure it has the correct value from localStorage
    initParticipantInput()

    // Setup address form
    setupAddressForm()

    // Setup activity address form
    setupActivityAddressForm()

    // Setup extras popup events
    setupExtrasPopupEvents()

    // Setup transport removal confirmation
    setupTransportRemovalConfirmation()

    // Setup quote request handling
    setupQuoteRequestHandling()

    // Track cart view once when the cart loads
    document.addEventListener('cart-loaded', () => {
      const cart = cartStore.get()

      // Only track if cart has items
      if (cart.hotels.length > 0 || cart.activities.length > 0) {
        const items = getCartItemsForTracking()

        // Track the view_cart event
        trackEvent({
          ga: {
            event_name: 'view_cart',
            params: {
              currency: 'PLN',
              value: items
                .filter((item) => item.item_category === 'hotel' || item.item_category === 'activity')
                .reduce((acc, item) => acc + item.item_price, 0),
              items: items.map((item) => ({
                item_id: item.item_id,
                item_name: item.item_name,
              })),
            },
          },
          meta: {
            event_name: 'ViewCart',
            content_name: document.title,
            params: {
              content_ids: items.map((item) => item.item_id),
            },
          },
        })
      }
    })

    // Then load cart items
    debouncedLoadCartItems()
  })

  // Helper function to get cart items for tracking events
  function getCartItemsForTracking() {
    const items: any[] = []

    // Add hotels to tracking
    cachedCartData.hotels.forEach((hotel) => {
      items.push({
        item_id: hotel._id,
        item_name: hotel.name,
        item_price: hotel.pricing?.pricePerPerson,
        item_category: 'hotel',
      })
    })

    // Add activities to tracking
    cachedCartData.activities.forEach((activity) => {
      items.push({
        item_id: activity._id,
        item_name: activity.name,
        item_price: activity.pricing?.additionalPersonPrice,
        item_category: 'activity',
      })
    })

    // Add extras to tracking
    const extrasIds = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')
    if (extrasIds.length > 0) {
      const extrasList = document.querySelector('.extras .list')
      if (extrasList) {
        const extrasData = JSON.parse(extrasList.getAttribute('data-addons-data') || '{}')

        extrasIds.forEach((item: { id: string; count?: number }) => {
          if (item.id === 'transport') {
            items.push({
              item_id: 'transport',
              item_name: t.transportAddonName,
              item_price: extrasData.transportOptions.pricing,
              item_category: 'extra',
            })
          } else {
            const addonData = extrasData.addonsList.find(
              (addon: { _key: string; name: string }) => addon._key === item.id
            )
            if (addonData) {
              items.push({
                item_id: addonData._key,
                item_name: addonData.name,
                item_price: addonData.pricing,
                item_category: 'extra',
              })
            }
          }
        })
      }
    }

    return items
  }

  // Modified toggleAddon to update transport address display and refresh popup list
  async function toggleAddon(item: HTMLElement, isSelected: boolean) {
    // Update data attribute
    item.dataset.selected = isSelected.toString()

    // Get addon ID
    const addonId = item.dataset.addonId
    if (!addonId) return

    // Update the checkbox to match the selected state
    const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
    if (checkbox) {
      checkbox.checked = isSelected
    }

    // Update localStorage
    updateOrderAddons(addonId, isSelected)

    // Find and update all instances of this addon (both in main list and popup)
    document.querySelectorAll(`.extra-item[data-addon-id="${addonId}"]`).forEach((element) => {
      element.setAttribute('data-selected', isSelected.toString())
      const elementCheckbox = element.querySelector('input[type="checkbox"]') as HTMLInputElement
      if (elementCheckbox) {
        elementCheckbox.checked = isSelected
      }
    })

    // Update show more button visibility
    const showMoreWrapper = document.querySelector('.show-more-wrapper') as HTMLElement
    if (showMoreWrapper) {
      const allAddons = document.querySelectorAll('.extras .list .extra-item')
      const selectedAddons = document.querySelectorAll('.extras .list .extra-item[data-selected="true"]')

      // Show the button if not all addons are selected
      if (selectedAddons.length < allAddons.length) {
        showMoreWrapper.style.display = 'flex'
      } else {
        showMoreWrapper.style.display = 'none'
      }
    }

    // Special handling for transport
    if (addonId === 'transport') {
      // If deselecting, remove address from localStorage
      if (!isSelected) {
        localStorage.removeItem('transport_address')
      }

      // Update address display for transport with a delay to ensure the DOM is ready
      setTimeout(() => {
        updateTransportCardWithAddress()
      }, 100)
    }

    // Refresh the popup list if it's open
    const popupContainer = document.querySelector(
      '.popup-content[data-popup-id="extras-popup-container"]'
    ) as HTMLElement
    if (popupContainer && popupContainer.offsetParent !== null) {
      // Check if popup is visible
      // Get all addons data from the main list
      const extrasData = JSON.parse(document.querySelector('.extras .list')?.getAttribute('data-addons-data') || '{}')

      // Create a combined list of all addons
      const allAddons: Array<{
        _key: string
        name: string
        image: any
        pricing: any
      }> = []

      // Add transport option
      if (extrasData.transportOptions) {
        allAddons.push({
          _key: 'transport',
          name: t.transportAddonName,
          image: extrasData.transportOptions.image,
          pricing: extrasData.transportOptions.pricing,
        })
      }

      // Add regular addons from Sanity
      if (extrasData.addonsList && Array.isArray(extrasData.addonsList)) {
        allAddons.push(...extrasData.addonsList)
      }

      // Get current selections from localStorage
      const currentSelectedAddons: Array<{ id: string; count?: number }> = JSON.parse(
        localStorage.getItem('cart_order_addons') || '[]'
      )

      // Sort addons - selected first
      const sortedAddons = [...allAddons].sort((a, b) => {
        const aSelected = currentSelectedAddons.some((item) => item.id === a._key) ? 1 : 0
        const bSelected = currentSelectedAddons.some((item) => item.id === b._key) ? 1 : 0
        return bSelected - aSelected // Descending order (selected first)
      })

      // Refresh the popup without closing and reopening it
      refreshPopupList(sortedAddons)
    }

    // Completely rebuild the addon list to ensure correct order
    await refreshExtrasList()
  }

  // Function to refresh the popup list without closing/reopening
  async function refreshPopupList(sortedAddons: Array<{ _key: string; name: string; image: any; pricing: any }>) {
    const extrasList = document.querySelector('.popup-content[data-popup-id="extras-popup-container"] .extras-list')
    if (!extrasList) return

    // Save scroll position
    const scrollPosition = extrasList.scrollTop

    // Clear content
    extrasList.innerHTML = ''

    // Get the latest addon selections from localStorage
    const currentSelectedAddons: Array<{ id: string; count?: number }> = JSON.parse(
      localStorage.getItem('cart_order_addons') || '[]'
    )

    // Rebuild the list with the sorted addons
    for (const addon of sortedAddons) {
      // Find existing element in the main list
      const existingElement = document.querySelector(
        `.extra-item[data-addon-id="${addon._key}"]:not([data-in-popup="true"])`
      ) as HTMLElement

      if (existingElement) {
        // Clone the existing element without event listeners
        const clonedElement = existingElement.cloneNode(true) as HTMLElement

        // Update selected state if needed
        const isSelected = currentSelectedAddons.some((item) => item.id === addon._key)
        const checkboxElem = clonedElement.querySelector('input[type="checkbox"]') as HTMLInputElement
        if (checkboxElem) {
          checkboxElem.checked = isSelected
        }
        clonedElement.dataset.selected = isSelected.toString()
        clonedElement.dataset.inPopup = 'true'

        extrasList.appendChild(clonedElement)
      } else {
        // If element doesn't exist yet (not in initial 6), create a new one
        const newIsSelected = currentSelectedAddons.some((item) => item.id === addon._key)
        const extraElement = await renderExtra(addon, newIsSelected, true)
        if (extraElement) {
          extrasList.appendChild(extraElement)
        }
      }
    }

    // Restore scroll position
    extrasList.scrollTop = scrollPosition
  }

  // Function to open addons popup with pre-sorted items
  async function openAddonsPopup(sortedAddons: Array<{ _key: string; name: string; image: any; pricing: any }>) {
    // Clear the template popup list first - this is what will be used when the popup opens
    const popupTemplateList = document.querySelector(
      '.popup-content[data-popup-id="extras-popup-container"] .extras-list'
    )
    if (popupTemplateList) {
      popupTemplateList.innerHTML = ''

      // Get current selections
      const currentSelectedAddons = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')

      // Pre-populate with sorted addons
      for (const addon of sortedAddons) {
        const isSelected = currentSelectedAddons.some((item: any) => item.id === addon._key)
        const extraElement = await renderExtra(addon, isSelected, true)
        if (extraElement) {
          popupTemplateList.appendChild(extraElement)
        }
      }
    }

    // Now trigger the popup - it will already have sorted content
    const popupTrigger = document.getElementById('extras-popup-trigger')
    if (popupTrigger) {
      popupTrigger.click()
    }
  }

  // Modify renderExtra to handle transport special case - Fix address display insertion
  async function renderExtra(
    extra: {
      _key: string
      name: string
      image: any
      pricing: {
        type?: string
        fixedPrice?: number
        basePrice?: number
        maxKilometers?: number
        pricePerKm?: number
        threshold?: {
          basePrice: number
          maxUnits: number
          additionalPrice: number
          singular: string
        }
      }
    },
    isSelected: boolean = false,
    inPopup: boolean = false
  ): Promise<HTMLElement | null> {
    const templateElement = document.getElementById('extras-template') as HTMLTemplateElement | null
    if (!templateElement) return null

    const clone = templateElement.content.cloneNode(true) as DocumentFragment
    const item = clone.querySelector('.extra-item') as HTMLElement
    if (inPopup) {
      item.dataset.inPopup = 'true'
    }

    // Set data attributes
    item.dataset.addonId = extra._key
    item.dataset.selected = isSelected.toString()

    // Setup image
    if (extra.image) {
      const imgWrapper = item.querySelector('.img-wrapper')!
      const optimizedImage = await optimizeImage({
        image: extra.image.asset.url,
        width: extra.image.asset.metadata.dimensions.width,
        height: extra.image.asset.metadata.dimensions.height,
      })

      const img = document.createElement('img')
      img.src = optimizedImage.src
      img.srcset = optimizedImage.srcSet.attribute
      img.sizes = ''
      img.alt = extra.name
      img.loading = 'lazy'
      imgWrapper.appendChild(img)
    }

    // Set name and price
    const nameElement = item.querySelector('.name')!
    nameElement.textContent = extra.name

    const priceElement = item.querySelector('.price')!
    const priceDetailsElement = item.querySelector('.price-details')!

    const plusIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" fill="none"><path stroke="#F67258" stroke-linecap="round" d="M9 6.963H6m0 0H3m3 0v-3m0 3v3"/></svg>`

    // Handle different pricing types
    if (extra._key === 'transport') {
      // Special handling for transport with new kilometer-based pricing
      if (extra.pricing.maxKilometers) {
        priceElement.innerHTML = `<strong>${t.from} ${extra.pricing.basePrice} ${t.currency}</strong><span>/ ${t.to} ${extra.pricing.maxKilometers} km</span>`
        priceDetailsElement.innerHTML = `${plusIcon} <span>${t.additionalKilometer}</span><strong>${extra.pricing.pricePerKm} ${t.currency}</strong>`
      } else {
        priceElement.innerHTML = `<strong>${extra.pricing.basePrice} ${t.currency}</strong>`
        priceDetailsElement.textContent = ''
      }
    } else if (extra.pricing.type === 'fixed' && extra.pricing.fixedPrice) {
      priceElement.innerHTML = `<strong>${extra.pricing.fixedPrice} ${t.currency}</strong>`
      priceDetailsElement.textContent = ''
    } else if (extra.pricing.type === 'threshold' && extra.pricing.threshold) {
      const { basePrice, maxUnits, additionalPrice } = extra.pricing.threshold
      priceElement.innerHTML = `<strong>${t.from} ${basePrice} ${t.currency}</strong><span>/ ${t.to} ${maxUnits} ${t.people}</span>`
      priceDetailsElement.innerHTML = `${plusIcon} <span>${t.additionalPerson}</span><strong>${additionalPrice} ${t.currency}</strong>`
    }

    // Setup checkbox
    const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement
    if (checkbox) {
      checkbox.checked = isSelected

      // Add event listeners only if not in popup
      if (!inPopup) {
        // Special handling for transport
        if (extra._key === 'transport') {
          checkbox.addEventListener('change', async (e) => {
            e.stopPropagation()
            e.preventDefault() // Prevent default to handle manually

            // Determine the target state - if checkbox is currently checked, we want to uncheck (remove)
            // If it's unchecked, we want to check (add)
            const targetState = checkbox.checked
            await handleTransportToggle(item, targetState)
          })

          item.addEventListener('click', async (e) => {
            if (e.target === checkbox || (checkbox && checkbox.contains(e.target as Node))) {
              return
            }
            e.preventDefault()

            // Toggle from current state - if item is selected, the target state is unselected
            const currentState = item.dataset.selected === 'true'
            await handleTransportToggle(item, !currentState)
          })

          item.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault()

              // Toggle from current state
              const currentState = item.dataset.selected === 'true'
              await handleTransportToggle(item, !currentState)
            }
          })
        } else {
          // Regular addons
          checkbox.addEventListener('change', async (e) => {
            e.stopPropagation()
            await toggleAddon(item, checkbox.checked)
          })

          item.addEventListener('click', async (e) => {
            if (e.target === checkbox || (checkbox && checkbox.contains(e.target as Node))) {
              return
            }
            checkbox.checked = !checkbox.checked
            await toggleAddon(item, checkbox.checked)
          })

          item.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault()
              checkbox.checked = !checkbox.checked
              await toggleAddon(item, checkbox.checked)
            }
          })
        }
      }
    }

    // If it's a transport item and is selected, add address display
    if (extra._key === 'transport' && isSelected) {
      const addressData = JSON.parse(localStorage.getItem('transport_address') || '{}')
      if (Object.keys(addressData).length > 0) {
        // Create address display
        const addressDisplay = document.createElement('div')
        addressDisplay.setAttribute('data-address-display', '')

        const addressText = document.createElement('p')
        addressText.setAttribute('data-address-text', '')
        addressText.innerHTML = `
          <span>${addressData.street}, ${addressData.city}, (${addressData.postal})</span>
        `

        const editIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 17" fill="none"
              ><path
                fill="#F67258"
                d="M14.128 2.205a1.835 1.835 0 0 1 0 2.596l-.33.33a3.074 3.074 0 0 1-.356-.1 3.46 3.46 0 0 1-1.312-.828 3.46 3.46 0 0 1-.827-1.312 3.09 3.09 0 0 1-.1-.355l.33-.33a1.835 1.835 0 0 1 2.595 0ZM9.719 9.21c-.27.27-.404.404-.553.52a3.058 3.058 0 0 1-.565.349c-.17.081-.35.141-.712.262l-1.906.635a.495.495 0 0 1-.626-.626l.636-1.906c.12-.361.18-.542.261-.712.096-.2.213-.39.35-.565.115-.148.25-.283.52-.552L10.4 3.337a4.467 4.467 0 0 0 1.022 1.573c.538.538 1.11.847 1.573 1.022L9.72 9.21Z"
              ></path><path
                fill="#F67258"
                d="M13.69 14.025c.975-.976.975-2.548.975-5.69 0-1.033 0-1.895-.034-2.623l-4.242 4.241c-.234.235-.41.41-.608.565a4.057 4.057 0 0 1-.75.464c-.226.108-.463.186-.777.291l-1.954.652a1.495 1.495 0 0 1-1.891-1.891l.651-1.955c.105-.314.184-.55.292-.777.126-.266.282-.517.463-.75.155-.198.33-.374.565-.608l4.241-4.241c-.727-.035-1.59-.035-2.622-.035-3.143 0-4.714 0-5.69.976-.977.977-.977 2.548-.977 5.69 0 3.143 0 4.715.976 5.691.977.976 2.548.976 5.69.976 3.143 0 4.715 0 5.691-.976Z"
              ></path></svg
            >`

        const editButton = document.createElement('button')
        editButton.setAttribute('data-edit-address-button', '')
        editButton.innerHTML = `<div>${editIcon} ${editIcon}</div>  <span>${t.addressForm.editButton}</span>`
        editButton.addEventListener('click', (e) => {
          e.stopPropagation()
          // Open popup to edit address
          document.getElementById('transport-address-trigger')?.click()
        })

        // Add edit button first, then address text
        addressDisplay.appendChild(editButton)
        addressDisplay.appendChild(addressText)

        // Add to item after price info
        item.appendChild(addressDisplay)
      }
    }

    return item
  }

  // Modify extras popup handling for transport items
  function setupExtrasPopupEvents() {
    const extrasList = document.querySelector('.extras-list')
    if (!extrasList) return

    extrasList.addEventListener('click', async (e) => {
      const target = e.target as HTMLElement
      const addonItem = target.closest('.extra-item') as HTMLElement

      if (!addonItem) return

      // Only handle items in the popup
      if (addonItem.dataset.inPopup !== 'true') return

      // Get checkbox element inside the addon item
      const checkbox = addonItem.querySelector('input[type="checkbox"]') as HTMLInputElement
      if (!checkbox) return

      // Don't handle if click was on the checkbox itself (it will be handled naturally)
      if (target === checkbox || checkbox.contains(target as Node)) return

      // Get addon ID and current selection state
      const addonId = addonItem.dataset.addonId
      const isCurrentlySelected = addonItem.dataset.selected === 'true'

      // Special handling for transport in popup
      if (addonId === 'transport') {
        e.preventDefault()
        e.stopPropagation()

        // Instead of closing the extras popup, keep it open and just open the transport form on top
        if (!isCurrentlySelected) {
          // Adding transport
          localStorage.setItem('pending_transport_item', addonId)
          document.getElementById('transport-address-trigger')?.click()
        } else {
          // Removing transport
          localStorage.setItem('pending_transport_removal', addonId)
          document.getElementById('transport-remove-trigger')?.click()
        }
        return
      }

      // Handle regular addons in popup
      e.preventDefault()
      e.stopPropagation()

      // Toggle the checkbox visually
      checkbox.checked = !isCurrentlySelected

      // Find the corresponding addon in the main list - we need this to trigger its logic
      const mainListAddon = document.querySelector(
        `.extra-item[data-addon-id="${addonId}"]:not([data-in-popup="true"])`
      ) as HTMLElement

      if (mainListAddon) {
        // Use the existing toggleAddon function with the main list item
        await toggleAddon(mainListAddon, !isCurrentlySelected)
      } else {
        // If not found in main list, use the current popup item
        await toggleAddon(addonItem, !isCurrentlySelected)
      }

      // Update the current popup item's state to match
      addonItem.dataset.selected = (!isCurrentlySelected).toString()
      checkbox.checked = !isCurrentlySelected
    })

    // Handle checkbox clicks directly in the popup
    extrasList.addEventListener('change', async (e) => {
      const target = e.target as HTMLElement
      if (target.tagName !== 'INPUT' || (target as HTMLInputElement).type !== 'checkbox') return

      const addonItem = target.closest('.extra-item') as HTMLElement
      if (!addonItem || addonItem.dataset.inPopup !== 'true') return

      const addonId = addonItem.dataset.addonId
      const checkbox = target as HTMLInputElement
      const isSelected = checkbox.checked

      // Special handling for transport checkbox
      if (addonId === 'transport') {
        e.preventDefault()
        e.stopPropagation()

        // Prevent default checkbox behavior as we'll handle it ourselves
        checkbox.checked = !isSelected // Revert the checkbox state temporarily

        // Instead of closing the extras popup, keep it open and just open the transport dialogue on top
        if (!isSelected) {
          // If attempting to select (add) transport
          localStorage.setItem('pending_transport_item', addonId)
          document.getElementById('transport-address-trigger')?.click()
        } else {
          // If attempting to deselect (remove) transport
          localStorage.setItem('pending_transport_removal', addonId)
          document.getElementById('transport-remove-trigger')?.click()
        }

        return
      }

      // For regular addons - find the main list item
      const mainListAddon = document.querySelector(
        `.extra-item[data-addon-id="${addonId}"]:not([data-in-popup="true"])`
      ) as HTMLElement

      if (mainListAddon) {
        await toggleAddon(mainListAddon, isSelected)
      } else {
        await toggleAddon(addonItem, isSelected)
      }

      // Update current popup item to match
      addonItem.dataset.selected = isSelected.toString()
    })
  }

  // Function to update order addons in localStorage
  function updateOrderAddons(addonId: string, isSelected: boolean): void {
    let orderAddons: Array<{ id: string; count?: number }> = JSON.parse(
      localStorage.getItem('cart_order_addons') || '[]'
    )

    if (isSelected) {
      // Add if not already in the list
      if (!orderAddons.some((addon) => addon.id === addonId)) {
        orderAddons.push({ id: addonId, count: 1 })
      }
    } else {
      // Remove if in the list
      orderAddons = orderAddons.filter((addon) => addon.id !== addonId)
    }

    localStorage.setItem('cart_order_addons', JSON.stringify(orderAddons))

    // Update count displayed
    updateExtrasCount()

    // Dispatch event for other components that might need to know
    document.dispatchEvent(
      new CustomEvent('order-addons-updated', {
        detail: { addons: orderAddons },
      })
    )
  }

  // Function to update the extras count display
  function updateExtrasCount(): void {
    const orderAddons = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')
    const countElement = document.querySelector('.extras .count')
    if (countElement) {
      // Transport is no longer automatically included
      countElement.textContent = orderAddons.length.toString()
    }
  }

  // Function to load cart extras
  async function loadCartExtras() {
    const extrasList = document.querySelector('.extras .list')
    if (!extrasList) return

    // Get extras data
    const extrasData = JSON.parse(extrasList.getAttribute('data-addons-data') || '{}')
    const orderAddons: Array<{ id: string; count?: number }> = JSON.parse(
      localStorage.getItem('cart_order_addons') || '[]'
    )

    // Clear list first
    extrasList.innerHTML = ''

    // Prepare arrays for selected and unselected addons
    const selectedAddons: Array<{ _key: string; name: string; image: any; pricing: any }> = []
    const unselectedAddons: Array<{ _key: string; name: string; image: any; pricing: any }> = []

    // Create a combined list of all addons
    const allAddons: Array<{
      _key: string
      name: string
      image: any
      pricing: {
        type: string
        fixedPrice?: number
        threshold?: {
          basePrice: number
          maxUnits: number
          additionalPrice: number
          singular: string
        }
      }
    }> = []

    // Add transport option
    if (extrasData.transportOptions) {
      allAddons.push({
        _key: 'transport',
        name: t.transportAddonName,
        image: extrasData.transportOptions.image,
        pricing: extrasData.transportOptions.pricing,
      })
    }

    // Add regular addons from Sanity
    if (extrasData.addonsList && Array.isArray(extrasData.addonsList)) {
      allAddons.push(...extrasData.addonsList)
    }

    // Now sort addons into selected and unselected groups
    allAddons.forEach((addon) => {
      const isSelected = orderAddons.some((item) => item.id === addon._key)
      if (isSelected) {
        selectedAddons.push(addon)
      } else {
        unselectedAddons.push(addon)
      }
    })

    // First render ALL selected addons
    for (const addon of selectedAddons) {
      const extraElement = await renderExtra(addon, true)
      if (extraElement) {
        extrasList.appendChild(extraElement)
      }
    }

    // Calculate how many unselected addons to show initially
    // Show up to 6 total items in the initial view
    const maxInitialAddons = 6
    const remainingSlots = Math.max(0, maxInitialAddons - selectedAddons.length)

    // Then show some unselected addons (limited number)
    const visibleUnselectedAddons = unselectedAddons.slice(0, remainingSlots)
    const hiddenAddons = unselectedAddons.slice(remainingSlots)

    // Render visible unselected addons
    for (const addon of visibleUnselectedAddons) {
      const extraElement = await renderExtra(addon, false)
      if (extraElement) {
        extrasList.appendChild(extraElement)
      }
    }

    // Combine all addons for the popup, with selected first
    const sortedAddons = [...selectedAddons, ...unselectedAddons]

    // Setup show more button
    const showMoreButton = document.querySelector('.show-more-extras')
    if (showMoreButton) {
      showMoreButton.setAttribute('data-hidden-addons', JSON.stringify(hiddenAddons))

      // Hide button if no more addons to show
      const showMoreWrapper = document.querySelector('.show-more-wrapper')
      if (showMoreWrapper && hiddenAddons.length === 0) {
        if (showMoreWrapper instanceof HTMLElement) {
          showMoreWrapper.style.display = 'none'
        }
      }

      // Setup click event
      showMoreButton.addEventListener('click', () => {
        openAddonsPopup(sortedAddons)
      })
    }

    // Update count display
    updateExtrasCount()
  }

  // State management functions
  function showState(state: 'loading' | 'empty' | 'error' | 'content' | 'submit-loading' | 'submit-error') {
    // Get all state elements
    const states = document.querySelectorAll('.cart-container .state')

    // Hide all states
    states.forEach((el) => {
      ;(el as HTMLElement).style.display = 'none'
    })

    // Show requested state
    const stateEl = document.querySelector(`.state-${state}`) as HTMLElement | null
    if (stateEl) {
      stateEl.style.display = 'flex'
    }

    // Scroll to top of the page smoothly
    window.scrollTo({
      top: 0,
      behavior: 'instant',
    })
  }

  // Check cart before fetching
  function checkCartBeforeFetching() {
    const cart = cartStore.get()
    const hasItems = cart.hotels.length > 0 || cart.activities.length > 0

    if (!hasItems) {
      // Show empty state immediately without fetching
      showState('empty')
      return false
    }

    // Has items, proceed with fetching
    return true
  }

  // Function to debounce loadCartItems calls
  function debouncedLoadCartItems(isRetry = false) {
    if (loadCartItemsTimeout) {
      clearTimeout(loadCartItemsTimeout)
    }

    loadCartItemsTimeout = window.setTimeout(() => {
      loadCartItems(isRetry)
      loadCartItemsTimeout = null
    }, 100)
  }

  // Main function to load all cart items
  async function loadCartItems(isRetry = false) {
    // Prevent concurrent loading
    if (isLoadingCartItems) {
      return
    }

    isLoadingCartItems = true

    try {
      // Get cart data from store
      const cart = cartStore.get()

      // Check if cart has items before processing
      if (!checkCartBeforeFetching()) {
        return
      }

      // If all items are already cached and this is not a retry, use cached data
      if (cachedCartData.isComplete() && !isRetry) {
        // Additional validation: ensure cache data matches current cart state
        const cacheMatches =
          cachedCartData.hotels.length === cart.hotels.length &&
          cachedCartData.activities.length === cart.activities.length &&
          // Verify hotel IDs match
          cart.hotels.every((cartHotel) =>
            cachedCartData.hotels.some((cachedHotel) => cachedHotel._id === cartHotel.id)
          ) &&
          // Verify activity IDs match
          cart.activities.every((cartActivity) =>
            cachedCartData.activities.some((cachedActivity) => cachedActivity._id === cartActivity.id)
          )

        if (cacheMatches) {
          // Render items from cache
          await renderCartItems(cachedCartData.hotels, cachedCartData.activities)
          // Load extras
          await loadCartExtras()
          // Show content state
          showState('content')
          // Update participant alerts after everything is loaded
          setTimeout(() => {
            updateParticipantAlerts()
            // Update transport cards with address if needed
            updateTransportCardWithAddress()
            // Update gastronomy section visibility
            updateGastronomySectionVisibility()

            // Dispatch cart-loaded event after everything is ready
            if (!isRetry) {
              document.dispatchEvent(new CustomEvent('cart-loaded'))
            }
          }, 100)
          return
        } else {
          // Cache is stale, clear it
          cachedCartData.clear()
        }
      }

      // Fetch all hotels
      const hotelPromises = cart.hotels.map(async (item) => {
        try {
          const addonIds = item.addOns.map((addon) => addon.id)
          const hotelData = await fetchHotelData(item.id, addonIds)
          if (hotelData) {
            const matchedAddons = item.addOns
              .map((addon: AddonItem) => {
                const fullAddon = hotelData.addons?.addonsList?.find((a: any) => a._key === addon.id)
                return {
                  ...addon,
                  fullData: fullAddon || null,
                }
              })
              .filter((addon) => addon.fullData !== null)

            const enhancedHotelData = {
              ...hotelData,
              cartAddons: matchedAddons,
            }

            // Update cache
            cachedCartData.updateHotel(item.id, enhancedHotelData)

            return enhancedHotelData
          }
          return null
        } catch (error) {
          console.error(`Error fetching hotel ${item.id}:`, error)
          return null
        }
      })

      // Fetch all activities
      const activityPromises = cart.activities.map(async (item) => {
        try {
          const addonIds = item.addOns.map((addon) => addon.id)
          const activityData = await fetchActivityData(item.id, addonIds)
          if (activityData) {
            const matchedAddons = item.addOns
              .map((addon: AddonItem) => {
                const fullAddon = activityData.addons?.addonsList?.find((a: any) => a._key === addon.id)
                return {
                  ...addon,
                  fullData: fullAddon || null,
                }
              })
              .filter((addon) => addon.fullData !== null)

            const enhancedActivityData = {
              ...activityData,
              cartAddons: matchedAddons,
            }

            // Update cache
            cachedCartData.updateActivity(item.id, enhancedActivityData)

            return enhancedActivityData
          }
          return null
        } catch (error) {
          console.error(`Error fetching activity ${item.id}:`, error)
          return null
        }
      })

      // Wait for all fetches to complete
      const [hotels, activities] = await Promise.all([Promise.all(hotelPromises), Promise.all(activityPromises)])

      // Filter out null results
      const validHotels = hotels.filter(Boolean)
      const validActivities = activities.filter(Boolean)

      // Mark cache as loaded
      cachedCartData.isLoaded = true

      // If nothing was fetched successfully, show empty state
      if (validHotels.length === 0 && validActivities.length === 0) {
        showState('empty')
        return
      }

      // Render the cart items
      await renderCartItems(validHotels, validActivities)

      // Load extras
      await loadCartExtras()

      // Show content state
      showState('content')

      // Update participant alerts after everything is loaded
      setTimeout(() => {
        updateParticipantAlerts()
        // Update transport cards with address if needed
        updateTransportCardWithAddress()
        // Update gastronomy section visibility
        updateGastronomySectionVisibility()

        // Dispatch cart-loaded event after everything is ready
        if (!isRetry) {
          document.dispatchEvent(new CustomEvent('cart-loaded'))
        }
      }, 100)
    } catch (error) {
      console.error('Error loading cart items:', error)
      showState('error')
    } finally {
      isLoadingCartItems = false
    }
  }

  // Listen for cart updates (both hotels and activities)
  document.addEventListener('cart-updated', async (event) => {
    type CartEventDetail = {
      itemId: string
      itemType: 'hotels' | 'activities'
      action: 'remove' | 'update'
    }

    type CartAddon = {
      id: string
      count?: number
    }

    type CartItem = {
      id: string
      addOns: CartAddon[]
    }

    const detail = (event as CustomEvent<CartEventDetail>).detail
    if (!detail || !detail.itemId || !detail.itemType || !detail.action) return

    const item = document.querySelector(`[data-item-id="${detail.itemId}"]`) as HTMLElement | null
    if (!item) return

    if (detail.action === 'remove') {
      const cartHeadingCount = document.querySelector('.state-content .header .cart-heading .count')! as HTMLSpanElement
      // Animate removal and then remove from DOM
      item.classList.add('removing')
      setTimeout(() => {
        item.remove()

        // Get current cart state after removal
        const cart = cartStore.get()
        const hasHotels = cart.hotels.length > 0
        const hasActivities = cart.activities.length > 0

        // Update cache to remove the item
        if (detail.itemType === 'hotels') {
          cachedCartData.updateHotel(detail.itemId, null)
        } else if (detail.itemType === 'activities') {
          cachedCartData.updateActivity(detail.itemId, null)
        }

        // Check if there are no more items of this type
        const section = document.querySelector(`.${detail.itemType}-section`)
        const otherType = detail.itemType === 'hotels' ? 'activities' : 'hotels'
        const otherSection = document.querySelector(`.${otherType}-section`)
        const updatedItemType = detail.itemType === 'hotels' ? 'hotel' : 'activity'

        // Update main cart count
        cartHeadingCount.textContent = `${cart.hotels.length + cart.activities.length}`

        if (section) {
          const remainingItems = section.querySelectorAll(`.${updatedItemType}-item`).length
          // Update count
          const countElement = section.querySelector('.count')
          if (countElement) {
            countElement.textContent = remainingItems.toString()
          }

          // If no more items of this type, render empty section alert
          if (remainingItems === 0) {
            const sectionList = section.querySelector('.list') as HTMLElement
            if (sectionList) {
              // Clear any existing content
              sectionList.innerHTML = ''

              // Render empty section alert for this section
              const sectionType = detail.itemType as 'hotels' | 'activities'
              renderEmptySectionAlert(sectionList, sectionType)
            }
          }
        }

        // Handle other section visibility and empty state
        if (otherSection) {
          const otherItemType = otherType === 'hotels' ? 'hotel' : 'activity'
          const hasOtherItems = otherSection.querySelectorAll(`.${otherItemType}-item`).length > 0

          if (!hasOtherItems) {
            const otherList = otherSection.querySelector('.list') as HTMLElement
            if (otherList && otherList.querySelector('.alert-item') === null) {
              // Only render if there's no alert already
              otherList.innerHTML = ''
              renderEmptySectionAlert(otherList, otherType as 'hotels' | 'activities')
            }
          }
        }

        // Check if cart is completely empty
        if (!hasHotels && !hasActivities) {
          // Show empty state and hide content state
          showState('empty')
        }

        // Update gastronomy section visibility when hotels change
        if (detail.itemType === 'hotels') {
          updateGastronomySectionVisibility()
        }
      }, 300)
    } else if (detail.action === 'update') {
      // Update addons list if it exists
      const addonList = item.querySelector('.addon-list')
      if (addonList) {
        const cart = cartStore.get()
        const cartItem = cart[detail.itemType].find((i: CartItem) => i.id === detail.itemId)
        addonList.innerHTML = ''

        if (cartItem && cartItem.addOns.length > 0) {
          // Try to get addon names from the data attribute first
          let addonsNames = []
          try {
            addonsNames = JSON.parse(item.getAttribute('data-addon-names') || '[]')
          } catch {
            addonsNames = []
          }

          // If data-addon-names is empty or incomplete, try to get from cache
          if (addonsNames.length === 0) {
            const cachedItemData =
              detail.itemType === 'hotels'
                ? cachedCartData.hotels.find((h) => h._id === detail.itemId)
                : cachedCartData.activities.find((a) => a._id === detail.itemId)

            if (cachedItemData && cachedItemData.addons?.fullAddonsList) {
              addonsNames = cachedItemData.addons.fullAddonsList.map((addon: any) => ({
                name: addon.name,
                id: addon._key,
              }))

              // Update the data attribute for future reference
              item.setAttribute('data-addon-names', JSON.stringify(addonsNames))
            }
          }

          cartItem.addOns.forEach((addon: CartAddon) => {
            const addonInfo = addonsNames.find((a: any) => a.id === addon.id)
            const li = document.createElement('li')

            if (addonInfo) {
              li.innerHTML = addon.count ? `${addonInfo.name}: <strong>${addon.count}</strong>` : addonInfo.name
            } else {
              // Fallback if addon name is not found
              li.innerHTML = addon.count ? `Addon: <strong>${addon.count}</strong>` : 'Addon'
            }
            addonList.appendChild(li)
          })
        }

        // Update addons button state
        const addonsButton = item.querySelector('.addons')
        if (addonsButton) {
          const hasAddons = cartItem && cartItem.addOns.length > 0
          addonsButton.setAttribute('data-is-editing', hasAddons ? 'true' : 'false')
          const span = addonsButton.querySelector('.text')
          if (span) {
            span.innerHTML = hasAddons ? t.editAddons : `${t.addons} <strong>${t.optional}</strong>`
          }
        }
      }
    }
  })

  // Cached data store for hotels and activities
  const cachedCartData = {
    hotels: [] as ExtendedHotelData[],
    activities: [] as ExtendedActivityData[],
    isLoaded: false,

    // Method to clear cache
    clear() {
      this.hotels = []
      this.activities = []
      this.isLoaded = false
    },

    // Method to update a specific hotel
    updateHotel(hotelId: string, data: ExtendedHotelData | null) {
      if (!data) {
        this.hotels = this.hotels.filter((h) => h._id !== hotelId)
        return
      }

      const index = this.hotels.findIndex((h) => h._id === hotelId)
      if (index >= 0) {
        this.hotels[index] = data
      } else {
        this.hotels.push(data)
      }
    },

    // Method to update a specific activity
    updateActivity(activityId: string, data: ExtendedActivityData | null) {
      if (!data) {
        this.activities = this.activities.filter((a) => a._id !== activityId)
        return
      }

      const index = this.activities.findIndex((a) => a._id === activityId)
      if (index >= 0) {
        this.activities[index] = data
      } else {
        this.activities.push(data)
      }
    },

    // Method to check if all items in the cart are cached
    isComplete() {
      const cart = cartStore.get()

      // Check if all hotels in cart are in cache
      const allHotelsCached = cart.hotels.every((item) => this.hotels.some((h) => h._id === item.id))

      // Check if all activities in cart are in cache
      const allActivitiesCached = cart.activities.every((item) => this.activities.some((a) => a._id === item.id))

      return allHotelsCached && allActivitiesCached
    },
  }

  // Function to check if activity address is needed
  function needsActivityAddress(): boolean {
    const cart = cartStore.get()

    // If we have hotels, activity addresses don't matter (hotels take precedence)
    if (cart.hotels.length > 0) {
      return false
    }

    // If we have no activities, no address needed
    if (cart.activities.length === 0) {
      return false
    }

    const hasNationwideActivities = cachedCartData.activities.some(
      (activity) => activity.location?.isNationwide === true
    )

    return hasNationwideActivities
  }

  // Setup activity address form events
  function setupActivityAddressForm() {
    // Listen for activity address form submission
    document.addEventListener('activity-address-submitted', (event: Event) => {
      const customEvent = event as CustomEvent
      const addressData = customEvent.detail?.data

      if (!addressData) return

      // Store address data in localStorage
      localStorage.setItem('activity_address', JSON.stringify(addressData))

      // Close popup
      const closeBtn = document.querySelector('.activity-address-popup .CloseButton')
      if (closeBtn && closeBtn instanceof HTMLElement) {
        closeBtn.click()
      }

      // Proceed with quote submission
      proceedWithQuoteSubmission()
    })

    // Setup popup close event to reset form state
    const activityAddressPopup = document.querySelector('.activity-address-popup')
    if (activityAddressPopup) {
      const popupWindow = activityAddressPopup.closest('.popup-window')

      if (popupWindow) {
        // Create a MutationObserver to watch for aria-hidden changes
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'aria-hidden') {
              const isHidden = popupWindow.getAttribute('aria-hidden') === 'true'
              if (isHidden) {
                // Popup is closing - dispatch reset event
                document.dispatchEvent(new CustomEvent('activity-address-reset'))
              } else {
                // Popup is opening - also dispatch reset event to ensure clean state
                document.dispatchEvent(new CustomEvent('activity-address-reset'))
              }
            }
          })
        })

        // Start observing
        observer.observe(popupWindow, {
          attributes: true,
          attributeFilter: ['aria-hidden'],
        })
      }
    }
  }

  // Dynamic Gastronomy functionality
  const dynamicGastronomyManager = {
    storageKey: 'cart_gastronomy_items',

    // Track if event listeners are attached to prevent duplicates
    listenersAttached: false,

    // Helper function to get translations
    getTranslations() {
      const cartElement = document.querySelector('[data-translations]') as HTMLElement
      return JSON.parse(cartElement?.getAttribute('data-translations') || '{}')
    },

    // Shared validation function for all gastronomy count inputs
    validateCount(input: HTMLInputElement): number {
      let value = input.value.replace(/[^\d]/g, '') // Remove non-digits
      let numValue = parseInt(value) || 1 // Default to 1 if empty or invalid

      // Ensure minimum value of 1
      if (numValue < 1) {
        numValue = 1
      }

      input.value = numValue.toString()
      return numValue
    },

    // Reset gastronomy form to default state
    resetForm() {
      const form = document.querySelector('.gastronomy-form') as HTMLFormElement
      const countInput = form?.querySelector('#service-count') as HTMLInputElement
      const mealOptions = form?.querySelector('.meal-options') as HTMLElement

      if (form) {
        form.reset()
      }

      if (countInput) {
        countInput.value = '10'
      }

      if (mealOptions) {
        mealOptions.style.display = 'none'
      }

      // Clear any error messages
      this.clearErrors()
    },

    // Clear all error messages
    clearErrors() {
      const serviceTypeError = document.getElementById('service-type-error') as HTMLElement
      const mealOptionsError = document.getElementById('meal-options-error') as HTMLElement
      const mealOptionsErrorInline = document.getElementById('meal-options-error-inline') as HTMLElement

      if (serviceTypeError) {
        serviceTypeError.style.display = 'none'
        serviceTypeError.textContent = ''
      }

      if (mealOptionsError) {
        mealOptionsError.style.display = 'none'
        mealOptionsError.textContent = ''
      }

      if (mealOptionsErrorInline) {
        mealOptionsErrorInline.style.display = 'none'
        mealOptionsErrorInline.textContent = ''
      }
    },

    // Show error message
    showError(elementId: string, message: string) {
      const errorElement = document.getElementById(elementId) as HTMLElement
      if (errorElement) {
        errorElement.textContent = message
        errorElement.style.display = 'inline-flex'
      }
    },

    // Validate form and show errors
    validateForm(): boolean {
      this.clearErrors()

      const form = document.querySelector('.gastronomy-form') as HTMLFormElement
      const selectedType = form.querySelector('input[name="service-type"]:checked') as HTMLInputElement
      const translations = this.getTranslations()

      let isValid = true

      // Check if service type is selected
      if (!selectedType) {
        this.showError(
          'service-type-error',
          translations.gastronomy?.alerts?.selectType || 'Please select service type'
        )
        isValid = false
      } else {
        const type = selectedType.value

        // Check if lunch/supper requires additional details
        if (type === 'lunch' || type === 'supper') {
          const levelInput = form.querySelector('input[name="meal-level"]:checked') as HTMLInputElement
          const styleInput = form.querySelector('input[name="meal-style"]:checked') as HTMLInputElement

          if (!levelInput || !styleInput) {
            this.showError(
              'meal-options-error-inline',
              translations.gastronomy?.alerts?.selectLevelAndStyle || 'Please select meal level and serving style'
            )
            isValid = false
          }
        } else if (type === 'open-bar') {
          // Open bar only needs level selection
          const levelInput = form.querySelector('input[name="meal-level"]:checked') as HTMLInputElement

          if (!levelInput) {
            this.showError(
              'meal-options-error-inline',
              translations.gastronomy?.alerts?.selectLevel || 'Please select level'
            )
            isValid = false
          }
        }
      }

      return isValid
    },

    // Get current gastronomy items from localStorage
    getItems() {
      try {
        const stored = localStorage.getItem(this.storageKey)
        const items = stored ? JSON.parse(stored) : []
        return items
      } catch (error) {
        console.error('Error parsing gastronomy items:', error)
        return []
      }
    },

    // Save items to localStorage
    saveItems(items: any[], skipRender: boolean = false) {
      try {
        localStorage.setItem(this.storageKey, JSON.stringify(items))
        if (!skipRender) {
          this.renderItems()
        }
      } catch (error) {
        console.error('Error saving gastronomy items:', error)
      }
    },

    // Generate unique ID for items
    generateId() {
      return 'gastronomy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
    },

    // Get type label in current language
    getTypeLabel(type: string) {
      const translations = this.getTranslations()
      return translations.gastronomy?.types?.[type] || type
    },

    // Get level/style labels
    getLevelLabel(level: string) {
      const translations = this.getTranslations()
      return translations.gastronomy?.levels?.[level] || level
    },

    getStyleLabel(style: string) {
      const translations = this.getTranslations()
      return translations.gastronomy?.styles?.[style] || style
    },

    // Add new gastronomy item
    addItem(type: string, count: number, options: any = {}) {
      const items = this.getItems()
      const id = Date.now().toString()
      const newItem = {
        id,
        type,
        count,
        options,
      }

      items.push(newItem)
      this.saveItems(items)

      this.renderItems()
    },

    // Remove gastronomy item
    removeItem(id: string) {
      const items = this.getItems()
      const filteredItems = items.filter((item: any) => item.id !== id)
      this.saveItems(filteredItems)

      // Show success toast notification
      const translations = this.getTranslations()
      showToast(
        translations.gastronomy?.success?.serviceRemoved || 'Gastronomy service removed successfully',
        'success'
      )

      // No need to call renderItems() here as saveItems() already does it
    },

    // Update item count
    updateItemCount(id: string, count: number) {
      const items = this.getItems()
      const item = items.find((item: any) => item.id === id)
      if (item) {
        item.count = Math.max(1, count)
        this.saveItems(items)
      }
    },

    // Update item options (for lunch/supper)
    updateItemOptions(id: string, options: any) {
      const items = this.getItems()
      const item = items.find((item: any) => item.id === id)
      if (item) {
        item.options = options
        this.saveItems(items)
      }
    },

    // Update item options (for lunch/supper) - for modal edits, skip re-render
    updateItemOptionsQuiet(id: string, options: any) {
      const items = this.getItems()
      const item = items.find((item: any) => item.id === id)
      if (item) {
        item.options = options
        this.saveItems(items, true) // Skip render to keep modal open
      }
    },

    // Render gastronomy items list
    renderItems() {
      const list = document.querySelector('.gastronomy-list') as HTMLElement
      const section = document.querySelector('.gastronomy-section') as HTMLElement
      if (!list || !section) return

      const items = this.getItems()

      // Clear the list
      list.innerHTML = ''

      if (items.length === 0) {
        // Show empty state
        section.classList.remove('has-items')
        section.classList.add('no-items')
      } else {
        // Show populated state
        section.classList.remove('no-items')
        section.classList.add('has-items')

        // Append each item element
        items.forEach((item: any) => {
          const itemElement = this.renderItem(item)
          list.appendChild(itemElement)
        })
      }

      this.attachItemListeners()
      this.updateCount()
    },

    // Render individual gastronomy item using template
    renderItem(item: any) {
      // Get the template
      const template = document.getElementById('gastronomy-template') as HTMLTemplateElement
      if (!template) {
        console.error('Gastronomy template not found')
        return document.createElement('div')
      }

      // Clone the template content
      const itemElement = template.content.cloneNode(true) as DocumentFragment
      const container = itemElement.querySelector('.gastronomy-item') as HTMLElement

      // Set data attributes
      container.setAttribute('data-id', item.id)
      container.setAttribute('data-type', item.type)

      // Populate the name
      const nameElement = container.querySelector('.item-name') as HTMLElement
      nameElement.textContent = this.getTypeLabel(item.type)

      // Handle options for lunch/supper/open-bar
      const hasOptions = item.type === 'lunch' || item.type === 'supper' || item.type === 'open-bar'
      const optionsElement = container.querySelector('.item-options') as HTMLElement
      const editButton = container.querySelector('.edit-options-btn') as HTMLElement

      if (hasOptions) {
        // Always show edit button for items that can have options
        editButton.style.display = 'block'
        editButton.setAttribute('data-id', item.id)

        if (item.options && item.options.level) {
          // Show existing options
          let optionsText = this.getLevelLabel(item.options.level)
          if (item.type === 'lunch' || item.type === 'supper') {
            optionsText += `, ${this.getStyleLabel(item.options.style)}`
          }
          optionsElement.textContent = optionsText
          optionsElement.style.display = 'flex'
        } else {
          // No options yet, but still show edit button so user can add them
          optionsElement.style.display = 'none'
        }
      } else {
        // Items that don't need options (coffee-break, grill)
        editButton.style.display = 'none'
        optionsElement.style.display = 'none'
      }

      // Set up counter control
      const countInput = container.querySelector('.count-input') as HTMLInputElement
      countInput.value = item.count.toString()
      countInput.setAttribute('data-id', item.id)

      const decreaseBtn = container.querySelector('.counter-decrease') as HTMLElement
      const increaseBtn = container.querySelector('.counter-increase') as HTMLElement
      const removeBtn = container.querySelector('.remove-item-btn') as HTMLElement

      decreaseBtn.setAttribute('data-id', item.id)
      increaseBtn.setAttribute('data-id', item.id)
      removeBtn.setAttribute('data-id', item.id)

      return itemElement
    },

    // Attach event listeners to rendered items
    attachItemListeners() {
      const gastronomyList = document.querySelector('.gastronomy-list') as HTMLElement
      if (!gastronomyList) return

      // Only attach listeners once to prevent duplicates
      if (this.listenersAttached) return

      this.listenersAttached = true

      // Use event delegation to handle all gastronomy item interactions
      gastronomyList.addEventListener('click', this.handleGastronomyClick.bind(this))
      gastronomyList.addEventListener('input', this.handleGastronomyInput.bind(this))
      gastronomyList.addEventListener('blur', this.handleGastronomyBlur.bind(this))
      gastronomyList.addEventListener('keydown', this.handleGastronomyKeydown.bind(this))
      gastronomyList.addEventListener('change', this.handleGastronomyChange.bind(this))
    },

    // Event delegation handlers
    handleGastronomyClick(e: Event) {
      const target = e.target as HTMLElement

      // Counter buttons
      if (target.closest('.counter-decrease') || target.closest('.counter-increase')) {
        const btn = target.closest('button') as HTMLButtonElement
        const id = btn.getAttribute('data-id')
        const isIncrease = btn.classList.contains('counter-increase')
        const input = document.querySelector(`.count-input[data-id="${id}"]`) as HTMLInputElement

        if (input && id) {
          const currentValue = this.validateCount(input)
          const newValue = isIncrease ? currentValue + 1 : Math.max(1, currentValue - 1)
          input.value = newValue.toString()
          this.updateItemCount(id, newValue)
        }
      }

      // Remove buttons
      else if (target.closest('.remove-item-btn')) {
        const btn = target.closest('button') as HTMLButtonElement
        const id = btn.getAttribute('data-id')
        if (id) {
          this.removeItem(id)
        }
      }

      // Edit options buttons
      else if (target.closest('.edit-options-btn')) {
        const btn = target.closest('button') as HTMLButtonElement
        const id = btn.getAttribute('data-id')
        if (id) {
          this.openEditOptionsModal(id)
        }
      }
    },

    handleGastronomyInput(e: Event) {
      const target = e.target as HTMLInputElement
      if (target.classList.contains('count-input')) {
        this.validateCount(target)
      }
    },

    handleGastronomyBlur(e: Event) {
      const target = e.target as HTMLInputElement
      if (target.classList.contains('count-input')) {
        const id = target.getAttribute('data-id')
        const value = this.validateCount(target)
        if (id) {
          this.updateItemCount(id, value)
        }
      }
    },

    handleGastronomyKeydown(e: KeyboardEvent) {
      const target = e.target as HTMLInputElement
      if (target.classList.contains('count-input')) {
        // Allow: backspace, delete, tab, escape, enter
        if (
          [8, 9, 27, 13, 46].indexOf(e.keyCode) !== -1 ||
          // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
          (e.keyCode === 65 && e.ctrlKey === true) ||
          (e.keyCode === 67 && e.ctrlKey === true) ||
          (e.keyCode === 86 && e.ctrlKey === true) ||
          (e.keyCode === 88 && e.ctrlKey === true)
        ) {
          return
        }
        // Ensure that it is a number and stop the keypress
        // But don't prevent Tab navigation (even with Shift)
        if (
          (e.shiftKey && e.keyCode !== 9) ||
          (!e.shiftKey && (e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105))
        ) {
          e.preventDefault()
        }
      }
    },

    handleGastronomyChange(e: Event) {
      const target = e.target as HTMLInputElement
      if (target.classList.contains('count-input')) {
        const id = target.getAttribute('data-id')
        const value = this.validateCount(target)
        if (id) {
          this.updateItemCount(id, value)
        }
      }
    },

    // Open edit options modal
    openEditOptionsModal(id: string) {
      // Check if modal is already open for this item
      const existingModal = document.querySelector(`.edit-options-modal[data-id="${id}"]`)
      if (existingModal) {
        // If modal is already open, just close it (don't reopen)
        existingModal.remove()
        return
      }

      const items = this.getItems()
      const item = items.find((item: any) => item.id === id)
      if (!item || (item.type !== 'lunch' && item.type !== 'supper' && item.type !== 'open-bar')) return

      // Create and show modal
      this.showEditModal(item, id)
    },

    // Show edit popup for lunch/supper options
    showEditModal(item: any, itemId: string) {
      const translations = this.getTranslations()

      // Find the edit button to position popup relative to it
      const editButton = document.querySelector(`.edit-options-btn[data-id="${itemId}"]`) as HTMLElement
      if (!editButton) return

      // Remove any existing modal first
      const existingModal = document.querySelector(`.edit-options-modal[data-id="${item.id}"]`)
      if (existingModal) {
        existingModal.remove()
      }

      // Get the template
      const template = document.getElementById('edit-gastronomy-modal-template') as HTMLTemplateElement
      if (!template) {
        console.error('Edit gastronomy modal template not found')
        return
      }

      // Clone the template content
      const modalElement = template.content.cloneNode(true) as DocumentFragment
      const container = modalElement.querySelector('.edit-options-modal') as HTMLElement

      // Set data attributes
      container.setAttribute('data-id', item.id)

      // Populate the modal title
      const titleElement = container.querySelector('.modal-title') as HTMLElement
      if (titleElement) {
        titleElement.textContent = `${translations.gastronomy?.editOptions || 'Edit options'}: ${this.getTypeLabel(item.type)}`
      }

      // Populate labels
      const levelLabel = container.querySelector('.level-label') as HTMLElement
      if (levelLabel) {
        levelLabel.textContent = translations.gastronomy?.level || 'Level:'
      }

      const styleLabel = container.querySelector('.style-label') as HTMLElement
      if (styleLabel) {
        styleLabel.textContent = translations.gastronomy?.servingStyle || 'Serving style:'
      }

      // Populate level options text within option-content spans
      const economyText = container.querySelector('.economy-text') as HTMLElement
      if (economyText) {
        economyText.textContent = translations.gastronomy?.levels?.economy || 'Economy'
      }

      const standardText = container.querySelector('.standard-text') as HTMLElement
      if (standardText) {
        standardText.textContent = translations.gastronomy?.levels?.standard || 'Standard'
      }

      const exclusiveText = container.querySelector('.exclusive-text') as HTMLElement
      if (exclusiveText) {
        exclusiveText.textContent = translations.gastronomy?.levels?.exclusive || 'Exclusive'
      }

      // Populate style options text within option-content spans
      const servedText = container.querySelector('.served-text') as HTMLElement
      if (servedText) {
        servedText.textContent = translations.gastronomy?.styles?.served || 'Served'
      }

      const buffetText = container.querySelector('.buffet-text') as HTMLElement
      if (buffetText) {
        buffetText.textContent = translations.gastronomy?.styles?.buffet || 'Buffet'
      }

      // Set checked states (with fallbacks for items without options)
      if (item.options?.level) {
        const levelInput = container.querySelector(
          `input[name="edit-level"][value="${item.options.level}"]`
        ) as HTMLInputElement
        if (levelInput) levelInput.checked = true
      } else {
        // Default to first option if no level is set
        const firstLevelInput = container.querySelector('input[name="edit-level"]') as HTMLInputElement
        if (firstLevelInput) firstLevelInput.checked = true
      }

      if (item.type !== 'open-bar') {
        // Handle style for lunch/supper
        if (item.options?.style) {
          const styleInput = container.querySelector(
            `input[name="edit-style"][value="${item.options.style}"]`
          ) as HTMLInputElement
          if (styleInput) styleInput.checked = true
        } else {
          // Default to first style option
          const firstStyleInput = container.querySelector('input[name="edit-style"]') as HTMLInputElement
          if (firstStyleInput) firstStyleInput.checked = true
        }
      }

      // Optimize layout for open-bar (single column)
      if (item.type === 'open-bar') {
        container.classList.add('single-column')
      }

      // Check if edit button already has a wrapper with position relative
      let wrapper = editButton.parentElement
      if (!wrapper || !wrapper.style.position) {
        // Create a new wrapper if needed
        wrapper = document.createElement('div')
        wrapper.style.position = 'relative'
        wrapper.style.display = 'inline-block'

        // Insert wrapper and move edit button into it
        editButton.parentNode?.insertBefore(wrapper, editButton)
        wrapper.appendChild(editButton)
      }

      // Add modal to the wrapper
      wrapper.appendChild(container)

      // Attach modal listeners
      this.attachEditModalListeners(item.id)
    },

    // Attach listeners to edit modal
    attachEditModalListeners(itemId: string) {
      const modal = document.querySelector(`.edit-options-modal[data-id="${itemId}"]`) as HTMLElement
      if (!modal) return

      // Auto-save on radio button changes without closing modal
      const radioButtons = modal.querySelectorAll('input[type="radio"]') as NodeListOf<HTMLInputElement>
      radioButtons.forEach((radio) => {
        radio.addEventListener('change', () => {
          const levelInput = modal.querySelector('input[name="edit-level"]:checked') as HTMLInputElement
          const styleInput = modal.querySelector('input[name="edit-style"]:checked') as HTMLInputElement

          // Get item to determine type
          const items = this.getItems()
          const item = items.find((item: any) => item.id === itemId)

          if (item?.type === 'open-bar') {
            // Open bar only needs level
            if (levelInput) {
              this.updateItemOptionsQuiet(itemId, {
                level: levelInput.value,
              })
              this.updateItemOptionsDisplay(itemId)
            }
          } else {
            // Lunch/supper needs both level and style
            if (levelInput && styleInput) {
              this.updateItemOptionsQuiet(itemId, {
                level: levelInput.value,
                style: styleInput.value,
              })
              this.updateItemOptionsDisplay(itemId)
            }
          }
        })
      })

      // Global click outside to close
      const handleOutsideClick = (e: Event) => {
        const target = e.target as HTMLElement
        if (!modal.contains(target)) {
          modal.remove()
          document.removeEventListener('click', handleOutsideClick)
        }
      }

      // Add the listener after a brief delay to prevent immediate closing
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick)
      }, 100)
    },

    // Update specific item's options display without full re-render
    updateItemOptionsDisplay(itemId: string) {
      const items = this.getItems()
      const item = items.find((item: any) => item.id === itemId)
      if (!item) return

      // Find the specific item element in the DOM
      const itemElement = document.querySelector(`.gastronomy-item[data-id="${itemId}"]`) as HTMLElement
      if (!itemElement) return

      const optionsElement = itemElement.querySelector('.item-options') as HTMLElement

      if (item.options) {
        let optionsText = this.getLevelLabel(item.options.level)
        // Only add style for lunch/supper, not for open-bar
        if (item.type === 'lunch' || item.type === 'supper') {
          optionsText += `, ${this.getStyleLabel(item.options.style)}`
        }
        optionsElement.textContent = optionsText
        optionsElement.style.display = 'flex'
      } else {
        optionsElement.style.display = 'none'
      }
    },

    // Setup form listeners for adding new items
    setupFormListeners() {
      const form = document.querySelector('.gastronomy-form') as HTMLFormElement
      if (!form) return

      const serviceTypeCheckboxes = form.querySelectorAll('input[name="service-type"]') as NodeListOf<HTMLInputElement>
      const countInput = form.querySelector('#service-count') as HTMLInputElement
      const mealOptions = form.querySelector('.meal-options') as HTMLElement
      const counterDecrease = form.querySelector('.quantity-decrease') as HTMLButtonElement
      const counterIncrease = form.querySelector('.quantity-increase') as HTMLButtonElement

      // Add real-time validation to service count input
      if (countInput) {
        countInput.addEventListener('input', () => {
          this.validateCount(countInput)
        })

        countInput.addEventListener('blur', () => {
          this.validateCount(countInput)
        })

        // Prevent non-numeric input
        countInput.addEventListener('keydown', (e) => {
          // Allow: backspace, delete, tab, escape, enter
          if (
            [8, 9, 27, 13, 46].indexOf(e.keyCode) !== -1 ||
            // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && e.ctrlKey === true) ||
            (e.keyCode === 67 && e.ctrlKey === true) ||
            (e.keyCode === 86 && e.ctrlKey === true) ||
            (e.keyCode === 88 && e.ctrlKey === true)
          ) {
            return
          }
          // Ensure that it is a number and stop the keypress
          if (
            (e.shiftKey && e.keyCode !== 9) ||
            (!e.shiftKey && (e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105))
          ) {
            e.preventDefault()
          }
        })
      }

      // Show/hide meal options based on type selection
      serviceTypeCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener('change', () => {
          // Clear service type error when user makes a selection
          const serviceTypeError = document.getElementById('service-type-error') as HTMLElement
          if (serviceTypeError) {
            serviceTypeError.style.display = 'none'
          }

          const selectedType = form.querySelector('input[name="service-type"]:checked') as HTMLInputElement
          const selectedValue = selectedType?.value || ''

          const hasOptionsNeeded =
            selectedValue === 'lunch' || selectedValue === 'supper' || selectedValue === 'open-bar'
          mealOptions.style.display = hasOptionsNeeded ? 'flex' : 'none'

          // Hide style selector for open-bar
          const styleField = mealOptions.querySelector('.form-field:last-child') as HTMLElement
          if (selectedValue === 'open-bar') {
            styleField.style.display = 'none'
          } else {
            styleField.style.display = 'block'
          }

          // Reset radio buttons when hiding
          if (!hasOptionsNeeded) {
            const radios = mealOptions.querySelectorAll('input[type="radio"]') as NodeListOf<HTMLInputElement>
            radios.forEach((radio) => (radio.checked = false))

            // Clear meal options error when switching away from lunch/supper
            const mealOptionsError = document.getElementById('meal-options-error-inline') as HTMLElement
            if (mealOptionsError) {
              mealOptionsError.style.display = 'none'
            }
          } else if (selectedValue === 'open-bar') {
            // Reset only style radios for open-bar, keep level selections
            const styleRadios = mealOptions.querySelectorAll('input[name="meal-style"]') as NodeListOf<HTMLInputElement>
            styleRadios.forEach((radio) => (radio.checked = false))
          }
        })
      })

      // Add listeners for meal options to clear errors
      const mealRadios = mealOptions.querySelectorAll('input[type="radio"]') as NodeListOf<HTMLInputElement>
      mealRadios.forEach((radio) => {
        radio.addEventListener('change', () => {
          // Clear meal options error when user makes selections
          const mealOptionsError = document.getElementById('meal-options-error-inline') as HTMLElement
          if (mealOptionsError) {
            mealOptionsError.style.display = 'none'
          }
        })
      })

      // Counter buttons with validation
      counterDecrease.addEventListener('click', () => {
        const currentValue = this.validateCount(countInput)
        const newValue = Math.max(1, currentValue - 1)
        countInput.value = newValue.toString()
      })

      counterIncrease.addEventListener('click', () => {
        const currentValue = this.validateCount(countInput)
        countInput.value = (currentValue + 1).toString()
      })

      // Form submission
      form.addEventListener('submit', (e) => {
        e.preventDefault()

        const count = this.validateCount(countInput) // Validate before submission

        // Validate the form
        if (!this.validateForm()) {
          return // Stop if validation fails
        }

        const selectedType = form.querySelector('input[name="service-type"]:checked') as HTMLInputElement
        const type = selectedType.value
        let options = {}

        // Get level and style for lunch/supper, only level for open-bar
        if (type === 'lunch' || type === 'supper') {
          const levelInput = form.querySelector('input[name="meal-level"]:checked') as HTMLInputElement
          const styleInput = form.querySelector('input[name="meal-style"]:checked') as HTMLInputElement

          options = {
            level: levelInput.value,
            style: styleInput.value,
          }
        } else if (type === 'open-bar') {
          const levelInput = form.querySelector('input[name="meal-level"]:checked') as HTMLInputElement

          if (levelInput) {
            options = {
              level: levelInput.value,
            }
          } else {
            options = {}
          }
        }

        // Add the item
        this.addItem(type, count, options)

        // Show success toast
        const translations = this.getTranslations()
        const successMessage = translations.gastronomy?.success?.serviceAdded || 'Gastronomy service added successfully'

        // Dispatch toast event
        document.dispatchEvent(
          new CustomEvent('show-toast', {
            detail: { message: successMessage, type: 'success' },
          })
        )

        // Reset form using shared function
        this.resetForm()

        // Close popup
        const closeBtn = document.querySelector('.gastronomy-popup .CloseButton') as HTMLButtonElement
        closeBtn?.click()
      })
    },

    // Initialize
    init() {
      // Set initial state
      const section = document.querySelector('.gastronomy-section') as HTMLElement
      if (section) {
        const items = this.getItems()
        if (items.length === 0) {
          section.classList.add('no-items')
        } else {
          section.classList.add('has-items')
        }
      }

      this.renderItems()
      this.setupFormListeners()
      this.updateCount()
    },

    // Update gastronomy count badge
    updateCount() {
      const countElement = document.getElementById('gastronomy-count') as HTMLElement
      if (!countElement) return

      const items = this.getItems()
      countElement.textContent = items.length.toString()
    },
  }

  // Initialize dynamic gastronomy functionality
  dynamicGastronomyManager.init()

  // Setup gastronomy popup trigger
  const gastronomyBtn = document.getElementById('add-gastronomy-btn') as HTMLButtonElement
  if (gastronomyBtn) {
    gastronomyBtn.addEventListener('click', () => {
      const popupTrigger = document.getElementById('gastronomy-popup-trigger') as HTMLButtonElement
      popupTrigger?.click()
    })
  }

  // Setup gastronomy popup trigger for empty state button
  const gastronomyBtnEmpty = document.getElementById('add-gastronomy-btn-empty') as HTMLButtonElement
  if (gastronomyBtnEmpty) {
    gastronomyBtnEmpty.addEventListener('click', () => {
      const popupTrigger = document.getElementById('gastronomy-popup-trigger') as HTMLButtonElement
      popupTrigger?.click()
    })
  }

  // Setup gastronomy popup close event to reset form
  const gastronomyPopup = document.querySelector('.gastronomy-popup') as HTMLElement
  if (gastronomyPopup) {
    const closeButtons = gastronomyPopup.querySelectorAll('[data-popup-close]') as NodeListOf<HTMLButtonElement>
    closeButtons.forEach((button) => {
      button.addEventListener('click', () => {
        // Reset form when popup closes
        dynamicGastronomyManager.resetForm()
      })
    })

    // Also reset when clicking outside the popup (overlay click)
    const popupWindow = gastronomyPopup.closest('.popup-window') as HTMLElement
    if (popupWindow) {
      popupWindow.addEventListener('click', (e) => {
        if (e.target === popupWindow) {
          dynamicGastronomyManager.resetForm()
        }
      })
    }
  }

  // Load cart items on page load
  debouncedLoadCartItems()

  // Form submission handler
  const form = document.querySelector('.Quote') as HTMLFormElement

  if (form) {
    form.addEventListener('submit', async (e) => {
      e.preventDefault()

      // Show loading state
      const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement
      if (submitButton) {
        submitButton.setAttribute('data-loading', 'true')
      }

      try {
        // Check if we need to collect activity address first
        if (needsActivityAddress()) {
          const addressData = localStorage.getItem('activity_address')
          if (!addressData || Object.keys(JSON.parse(addressData)).length === 0) {
            // Open activity address popup
            document.getElementById('activity-address-trigger')?.click()
            return
          }
        }

        // Check if transport is selected and we need address
        const orderAddons = JSON.parse(localStorage.getItem('cart_order_addons') || '[]')
        const hasTransport = orderAddons.some((addon: any) => addon.id === 'transport')

        if (hasTransport) {
          const transportAddress = localStorage.getItem('transport_address')
          if (!transportAddress || Object.keys(JSON.parse(transportAddress)).length === 0) {
            // Open transport address popup
            document.getElementById('transport-address-trigger')?.click()
            return
          }
        }

        // Proceed with quote submission
        await proceedWithQuoteSubmission()
      } catch (error) {
        console.error('Quote submission error:', error)
        showToast('Wystąpił błąd podczas wysyłania wyceny. Spróbuj ponownie.', 'error')
      } finally {
        // Hide loading state
        if (submitButton) {
          submitButton.setAttribute('data-loading', 'false')
        }
      }
    })
  }

  // Listen for participant count changes and sync with localStorage and transport form
  const participantInput = document.getElementById('participantCount') as HTMLInputElement
  if (participantInput) {
    // Load saved participant count on page load
    const savedCount = localStorage.getItem('cart_participant_count')
    if (savedCount) {
      participantInput.value = savedCount
      syncTransportPeopleWithParticipants(parseInt(savedCount))
    }

    function handleParticipantChange() {
      const value = participantInput.value
      localStorage.setItem('cart_participant_count', value)
      syncTransportPeopleWithParticipants(parseInt(value) || 0)

      // Update participant alerts
      setTimeout(() => {
        updateParticipantAlerts()
        // Update gastronomy calculations
        dynamicGastronomyManager.renderItems()
      }, 100)
    }

    participantInput.addEventListener('input', handleParticipantChange)
    participantInput.addEventListener('change', handleParticipantChange)
  }

  // Listen for date changes to update gastronomy calculations
  document.addEventListener('dates-updated', () => {
    setTimeout(() => {
      dynamicGastronomyManager.renderItems()
    }, 100)
  })

  // Also listen for when dates are cleared
  document.addEventListener('dates-cleared', () => {
    setTimeout(() => {
      dynamicGastronomyManager.renderItems()
    }, 100)
  })

  // Listen for cart changes to update gastronomy options
  // document.addEventListener('cart-updated', () => {
  //   setTimeout(() => {
  //     dynamicGastronomyManager.renderItems()
  //   }, 100)
  // })

  // Listen for cart loaded event to initialize gastronomy
  document.addEventListener('cart-loaded', () => {
    setTimeout(() => {
      dynamicGastronomyManager.renderItems()
    }, 100)
  })

  // Keyboard navigation for gastronomy items
  document.querySelectorAll('.toggle-gastronomy').forEach((toggle) => {
    toggle.addEventListener('keydown', (e) => {
      const event = e as KeyboardEvent
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault()

        // Find the checkbox and toggle it
        const checkbox = toggle.querySelector('.gastronomy-checkbox') as HTMLInputElement
        if (checkbox && !checkbox.disabled) {
          // Skip if it's grill and disabled
          const item = toggle.closest('.gastronomy-item') as HTMLElement
          if (item?.getAttribute('data-disabled') === 'true') {
            return
          }

          // Toggle the checkbox
          checkbox.checked = !checkbox.checked

          // Trigger the change event to run existing logic
          const changeEvent = new Event('change', { bubbles: true })
          checkbox.dispatchEvent(changeEvent)
        }
      }
    })
  })

  // Radio button change listeners
  document
    .querySelectorAll('input[type="radio"][name^="lunch-"], input[type="radio"][name^="dinner-"]')
    .forEach((radio) => {
      radio.addEventListener('change', (e) => {
        const input = e.target as HTMLInputElement
        const name = input.name
        const value = input.value

        if (name.includes('lunch-') || name.includes('dinner-')) {
          const type = name.includes('lunch-') ? 'lunch' : 'dinner'
          const currentSelections = dynamicGastronomyManager.getItems()
          const selection = currentSelections.find((item: any) => item.type === type)

          if (selection) {
            const property = name.includes('-level') ? 'level' : 'style'
            selection[property] = value
            dynamicGastronomyManager.saveItems(currentSelections)
          } else {
          }
        }
      })
    })
</script>
